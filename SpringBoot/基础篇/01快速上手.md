## 入门案例解析

### 仓库版本管理（起步依赖）

SpringBoot为我们定义了一系列的常用坐标版本和常用坐标组合，我们直接使用这些组合就可以了，避免了多种技术融合时的不兼容。

在pom.xml文件中的这段代码：*你的项目会自动继承这些依赖的推荐版本，无需在项目的pom.xml中显式声明依赖版*

```xml
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.3</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
//并且下面依赖的导入也使用到了依赖传递,starter对应着一系列依赖
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
```

也可以采用引入依赖的形式完成（阿里云）

#### parent

- 依赖管理，而非依赖。

- 减少依赖冲突

#### starter

- 决定是否使用依赖。
- 减少依赖配置。

每个starter都包含了一个或多个相关技术的默认版本库依赖，这意味着开发者只需添加一个starter依赖到项目中，就能获取到所有必需的库。

### 引导类

整个Boot工程的执行入口，初始化Spring容器，扫描包（注意类的路径）

run方法底层还是Spring容器。

```java
@SpringBootApplication//这个注解代码里包含了配置文件和扫描包
public class SpringbootDemo02Application {

    public static void main(String[] args) {
        ConfigurableApplicationContext rongqi = SpringApplication.run(SpringbootDemo02Application.class, args);
        BookController bookControllerBean = rongqi.getBean(BookController.class);
    }

}
```

### 内嵌Tomcat

将Tomcat包成一个对象，交给Spring去管理。



## 基础配置

### 备份副本，模版

<img src="../../Pic/image-20240319160050819.png" alt="image-20240319160050819" style="zoom:50%;" />

模版形式如上，**注意将pom中的artifactId改为模块名称**。

### 修改配置

在resources/application.properties下进行KEY-VALUE的设置。

例如修改浏览器的默认端口`server.port = 80`可以做到直接使用`http://localhost`访问，因为80是Http协议默认使用的端口号

但是，这里面的**配置也与对应的starter**依赖息息相关。

### 3种配置格式

- Properties,yml,yaml；优先级也是这个顺序（处于相同配置时）

- 推荐使用**yml格式**。YAML文件有两个扩展名.yml.yaml

### YAML格式

- 属性：空格 值（这个空格很重要）
- 读取YAML中的数据<img src="../../Pic/image-20240319171049460.png" alt="image-20240319171049460" style="zoom:50%;" />
- 引用文件中已存在的属性`${xxx}`；如果出现转义字符使用双引号包装
- 使用`@Autowired`自动装配将所有数据装到一个对象Environment中，使用`getProperty方法获取值`

#### 主流读取配置方式

1、在yml中将一堆配置信息封装为一个对象；

2、在外面提供对应的模型类（通过`@ConfigurationProperties(prefix="xxx")`注解进行联系



## 整合第三方技术

### JUNIT

<img src="../../Pic/image-20240319213128326.png" alt="image-20240319213128326" style="zoom:50%;" />

SpringBootTest注解的classes属性可以精准指定引导类（配置类）的位置——**测试类需要在引导类所在的包或者子包中。**

### Mybatis

- 勾选Mybatis和MysqlDriver依赖（注意starter发生了变化）

- 配置必要信息：<img src="../../Pic/image-20240319220318273.png" alt="image-20240319220318273" style="zoom:50%;" />

### Mybatis-plus

由于其不在Spring框架中，所以需要从Maven仓库中导入其对应的starter坐标  

并且提供对应的配置。

## 整合案例

### DAO层开发

MP的配置信息

```yaml
mybatis-plus:
  global-config:
    db-config:
      table-prefix: tbl_
      id-type: auto #??????????????
#mybatis-plus?????????????sql????????
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

在测试类中相关的写法：

```java
@SpringBootTest
public class BookDaoTestCase {
    @Autowired
    private BookDao bookDao;
    @Test
    void testGetById(){
        System.out.println(bookDao.selectById(1));
    }
    //分页操作
    @Test
    void testGetPage(){
        IPage page = new Page(1, 5);//显示第一页的5条数据
        bookDao.selectPage(page, null);
    }

    //条件查询
    @Test
    void testGetBy(){
        QueryWrapper<Book> qw = new QueryWrapper<>();
        qw.like("name", "Spring");
        //select * from tb where name like %Spring%
        bookDao.selectList(qw);
        //
        String name = null;
        LambdaQueryWrapper<Book> Lqw = new LambdaQueryWrapper<>();
        Lqw.like(name != null, Book::getName, "Spring");
        bookDao.selectList(Lqw);
    }
}

```

注意，上面的分页拦截器需要额外配置MPConfig类

```java
@Configuration
public class MPConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        //创建一个拦截器壳子，里面放入不同的拦截器（分页拦截器）；最后返回拦截器壳子
        MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor();
        mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return mybatisPlusInterceptor;
    }
}
```



在main中Dao的写法：使用MP的话直接继承BaseMapper，这样不用再写任何的sql语句注解

```java
@Mapper
public interface BookDao extends BaseMapper<Book> {

}
```



### 业务层开发

接口使用（继承）MP的`IService`来简化开发，**实现类继承ServiceImpl<M,T>类**简化开发（Mapper，Pojo)

上面是接口，下面是具体的实现类；其中的一般业务逻辑都已经被MP写好了

```java
public interface IBookService extends IService<Book> {
    //里面包含了通用方法，save,update,remove等，但是特殊的业务方法需要自己写
}

@Service
public class BookServiceImpl2 extends ServiceImpl<BookDao, Book> implements IBookService {

}
```

通用类基础上做重载或者添加功能

### 控制层（表现层）开发

Rest开发风格

- 四种Mapping：`GET查询 Post添加 Put修改 Delete删除`

参数注意事项：

- save和update（即添加修改）一般使用请求体`@RequestBody`传参JSON对象；

- 删除和查单个都使用id占位符+`@PathVariable`传参：
- 在Controller中也使用到了统一格式

```java
@RestController
@RequestMapping("/books")
public class BookController2Together {
    @Autowired
    private IBookService bookSer;
    @GetMapping
    public R getAll(){
        return new R(true, bookSer.list());
    }

    //Rest风格，GET查询，post添加，put修改，delete删除
    @PostMapping
    public R save(@RequestBody Book book){
        R r = new R(bookSer.save(book));
        return r;
    }
    @PutMapping
    public R update(@RequestBody Book book){
        R r = new R(bookSer.updateById(book));
        return r;
    }
  //单个参数：占位符+Path
    @DeleteMapping("{id}")
    public R delete(@PathVariable Integer id){
        R r = new R(bookSer.removeById(id));
        return r;
    }
    
}
```

#### 消息格式一致性处理R

注意：增删改返回的是布尔类型

需要设计一个模型类，**进行数据格式统一：前后端数据协议**

![image-20240320171941239](../../Pic/image-20240320171941239.png)

模型类R，作为Controller包下的Util，用来统一数据格式。

```java
@Data
/**
 * flag作为操作是否成功，true为成功
 * data作为真实数据
 */
public class R {
    private Boolean flag;
    private Object data;

    public R(Boolean flag){
        this.flag = flag;
    }

    public R(Boolean flag, Object data){
        this.flag = flag;
        this.data = data;
    }
}
```

### View层开发

前端发送异步请求，调用后端接口（有不同的异步请求，get、post、delete）

```java
getAll(){
	axios.get("/books").then((res) =>{
		console.log(res.data);//打印res中的数据
});
},
```

添加数据

```java
handleAdd(){
	//发送异步请求
	axios.post("/books",this.formData).the((res)=>{
	if(res.data.flag){
		this.dialogFormVisible = false;//关闭添加页面
		this.$message.success("添加成功");
}else{
	this.$message.error("添加失败");
}
}).finally(()=>){
	this.getAll();//刷新数据
}
}
```

删除操作（可以绑定当前行数据）

```java
handleDelete(row){
	axios.delete("/books/" + row.id).then((res) =>{//将id取出作为路径中的必须参数
		if(res.data.flag){
			this.$message.success("删除成功");
}else{
		this.$message.error("删除失败");
}
}).finally(()=>{
		this.getAll();
})
}
```

### 异常处理（格式）

```java
@RestControllerAdvice
public class ProjectExceptionAdvice {
    //拦截所有的异常信息
    @ExceptionHandler
    public R doException(Exception ex){
        //记录日志，通知运维，通知开发，返回统一格式R
        ex.printStackTrace();
        return new R(false, "服务器故障");
    }
}
```

