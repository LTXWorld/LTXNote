# Redis02实战

## 手机验证码功能

### 判断验证码

业务流程图

<img src="/Users/lutao/GitT/Pic/image-20240405102039335.png" alt="image-20240405102039335" style="zoom:50%;" />

前端发送过来的信息：

<img src="/Users/lutao/GitT/Pic/image-20240405101952754.png" alt="image-20240405101952754" style="zoom:50%;" />

代码实现过程：

在UserController中的sendCode方法调用UserService中的sendCode方法（自创）

- 注意`command+option+b`跳转到对应的接口方法实现类中
- 实现具体方法快捷键：`option+shift+enter`

### 基于验证码实现登录

前端信息：本次是JSON风格<img src="/Users/lutao/GitT/Pic/image-20240405161840175.png" alt="image-20240405161840175" style="zoom:50%;" /> 

业务流程：

<img src="/Users/lutao/GitT/Pic/image-20240405162349182.png" alt="image-20240405162349182" style="zoom:50%;" />

注意，不论用户是否存在，都要存放到session中

### 登录校验拦截器

Cookie中的JSESSIONID就是用户的登录凭证。

<img src="/Users/lutao/GitT/Pic/image-20240405195437472.png" alt="image-20240405195437472" style="zoom:50%;" />

业务流程

<img src="/Users/lutao/GitT/Pic/image-20240405195424607.png" alt="image-20240405195424607" style="zoom:50%;" />

需要拦截器

<img src="/Users/lutao/GitT/Pic/image-20240405200502141.png" alt="image-20240405200502141" style="zoom:50%;" />

- 为了防止所有的与用户有关的Controller中都要进行校验，所有请求先经过拦截器——将校验逻辑放在拦截器中，再由拦截器得到的信息传递到Controller中——为了线程安全，需要使用ThreadLocal。

代码实现

- 在Util中写一个拦截器
- 配置拦截器，使其生效
- 编写Controller中的对应api

### 集群Session共享问题

多台Tomcat服务器不共享session存储空间，换到另外一台服务器上登录信息会丢失——使用Redis代替。

<img src="/Users/lutao/GitT/Pic/image-20240406094136619.png" alt="image-20240406094136619" style="zoom:50%;" />

注意Redis存数据的key-value的数据类型。

### 基于Redis实现共享session登录

1、发送验证码

 <img src="/Users/lutao/GitT/Pic/image-20240406094959548.png" alt="image-20240406094959548" style="zoom:50%;" />

代码实现

- 使用String-String类型

- 注入Redis对象
- 注意设置有效期

```java
@Resource
private StringRedisTemplate stringRedisTemplate;
//保存验证码到redis，可以将变量换为常量
stringRedisTemplate.opsForValue().set("login:code:" + phone, code, 2, TimeUnit.MINUTES);
```

```java
//根据手机号发送验证码    
@Override
    public Result sendCode(String phone, HttpSession session) {
        //1校验手机号
        if (RegexUtils.isPhoneInvalid(phone)) {
            //2如果不符合返回错误信息
            return Result.fail("手机号格式错误");
        }

        //3符合，生成验证码
        String code = RandomUtil.randomNumbers(6);
        //新方法，保存到Redis中,键值对形式，键为手机号码，值为验证码
        stringRedisTemplate.opsForValue().set(RedisConstants.LOGIN_CODE_KEY + phone, code, RedisConstants.LOGIN_CODE_TTL, TimeUnit.MINUTES);
        //5发送验证码
        log.debug("发送成功"+code);
        return Result.ok();//返回工具类中Result的OK方法
    }
```



2、短信验证码登录、注册

<img src="/Users/lutao/GitT/Pic/image-20240406095038024.png" alt="image-20240406095038024" style="zoom:50%;" />

登录凭证从sessionID变为了Token，但是不像ID可以自带到cookie里，需要手动传回前端。

代码实现

- 存储时Value采用Hash结构
- 保存用户信息到redis中
- 随机生成Token令牌
- 注意有效期的设置——只要用户有在有效期内访问就不断更新有效期 （见下方拦截器优化）

```java
    @Override
    public Result login(LoginFormDTO loginForm, HttpSession session) {
        //1校验手机号
        String phone = loginForm.getPhone();
        if (RegexUtils.isPhoneInvalid(phone)) {
            //2如果不符合，返回错误信息
            return Result.fail("手机号格式错误");
        }
        //3校验验证码,从Redis中取出验证码

        String cachecode = stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + phone);
        String code = loginForm.getCode();//这是通过登录信息json中得到用户填的验证码
        if (cachecode == null || !cachecode.toString().equals(code)){
            //4如果不一致报错
            return Result.fail("验证码错误");
        }

        //5如果一致，根据手机号查询用户 select * from tb_user where phone = ?
        User user = query().eq("phone", phone).one();//使用到了Mybits-plus
        //6判断用户是否存在
        if (user == null){
            //不存在创建新用户，保存到数据库中（用到了MBP）
            user = creatUserWithPhone(phone);//一个新的自创方法，创建新用户，并存放到数据库中
        }

        //7将用户信息保存在Redis中
        //用户信息保存在Redis中，键为Token，值为Map（内部有多个键值对）
        String userToken = UUID.randomUUID().toString(true);
        String userTokenKey = RedisConstants.LOGIN_USER_KEY + userToken;
        //需要先将对象转为MAP集合,注意放入Redis之前要进行字符串序列化
        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);//将数据的粒度降级，UserDTO更加简洁
        Map<String, Object> map = BeanUtil.beanToMap(
                userDTO,
                new HashMap<>(),
                CopyOptions.create().ignoreNullValue()
                        .setFieldValueEditor((fileName, fileValue) -> fileValue.toString())//将所有属性变为String类型
        );
        //保存进Redis
        stringRedisTemplate.opsForHash().putAll(userTokenKey, map);

        //设置Redis有效期
        stringRedisTemplate.expire(userTokenKey, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);
        //将token返回给前端，相当于cookie中的sessionID

        return Result.ok(userToken);
    }
```



3、校验登录状态

业务流程

<img src="/Users/lutao/GitT/Pic/image-20240406101830648.png" alt="image-20240406101830648" style="zoom:50%;" />

代码实现

- 注意拦截器并没有交由Spring管理，所以不能像上面那样注入，需要自己创建对象——在MVCconfig对象中进行注入并给到new参数里面。
- 具体代码见下方优化，这里只给出MvcConfig的代码

```java
@Configuration
public class MVCConfigure implements WebMvcConfigurer {

    @Resource
    private StringRedisTemplate stringRedisTemplate;
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .excludePathPatterns(//这里在做拦截器的放行
                        "/user/code",
                        "/user/login",
                        "/blog/hot",
                        "/shop/**",
                        "/shop-type/**",
                        "/voucher/**"
                ).order(1);//order值越大执行优先级越低
        registry.addInterceptor(new RefreshTokenInterceptor(stringRedisTemplate)).order(0);//拦截所有请求，并且需要先执行
    }
}
```





### 登录拦截器优化

为了防止用户在不需要登录的页面上操作，反而导致没有激活有效期，我们需要在前面再加一个拦截器，*拦截一切路径，功能其实是查询Redis用户并保存*；让后面的拦截器去查线程里的用户。

<img src="/Users/lutao/GitT/Pic/image-20240406144814997.png" alt="image-20240406144814997" style="zoom:50%;" />

代码实现

第一个拦截器：Refresh很多功能拷贝自第二个

```java
public class RefreshTokenInterceptor implements HandlerInterceptor {

    private StringRedisTemplate stringRedisTemplate;

    public RefreshTokenInterceptor(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //1获取token,不需要拦截直接放行即可。
        String token = request.getHeader("authorization");
        if (StrUtil.isBlank(token)) {
            return true;
        }
        //基于Token获取redis中的用户
        String key = RedisConstants.LOGIN_USER_KEY + token;
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(key);
        //3判断用户是否存在
        if (userMap == null){
            return true;
        }
        //将查询到的Hash数据转为UserDTO对象
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
        //5存在，保存用户信息到ThreadLocal并放行
        UserHolder.saveUser(userDTO);

        //刷新Token的有效期
        stringRedisTemplate.expire(key, RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        //业务完成后，移除用户
        UserHolder.removeUser();
    }
}

```

第二个拦截器：

```java
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
              if (UserHolder.getUser() == null) {
            response.setStatus(401);
            //拦截
            return false;
        }
        return true;
    }
}
```



## 缓存

### 根据id查询商铺添加Redis缓存

业务流程：

<img src="/Users/lutao/GitT/Pic/image-20240406153302650.png" alt="image-20240406153302650" style="zoom:50%;" />

代码实现：

- 在Service的具体实现类中

```java
@Service
public class ShopServiceImpl extends ServiceImpl<ShopMapper, Shop> implements IShopService {
    @Resource
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public Result queryById(Long id) {
        String key = "cache:shop: " + id;
        //1查询redis中的商铺缓存
        String shopJSON = stringRedisTemplate.opsForValue().get(key);
        //2存在直接返回
        if (StrUtil.isNotBlank(shopJSON)) {
            Shop shop = JSONUtil.toBean(shopJSON, Shop.class);
            return Result.ok(shop);
        }
        //3不存在，根据id查询数据库
        Shop shop = getById(id);
        if (shop == null) {
            //4不存在报错
            return Result.fail("店铺不存在");
        }
        //5存在写入redis并返回
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));
        return Result.ok(shop);
    }
}
```

### 缓存更新

- 内存淘汰（低一致性）
- 超时剔除
- 主动更新（高一致性）三种方法——通常使用第一种方法。<img src="../Pic/image-20240406161910904.png" alt="image-20240406161910904" style="zoom:50%;" />

选择*更新数据库*与*删除缓存*操作的原子性——**单体系统，放在一个事务中；分布式系统采用分布式事务方案**。

不断地先后操作带来线程安全问题——**先操作数据库，再删除缓存**：因为缓存操作时间快，数据库操作时间太慢。（在缓存未命中时发生更新数据库并完成的机率小）

<img src="../Pic/image-20240406162856638.png" alt="image-20240406162856638" style="zoom:50%;" />

所以最后的方案是：

<img src="../Pic/image-20240406163406855.png" alt="image-20240406163406855" style="zoom:50%;" />

#### 查询商铺的缓存添加超时剔除和主动更新

业务流程

<img src="../Pic/image-20240406163504748.png" alt="image-20240406163504748" style="zoom:50%;" />

代码实现：

```java
    /**
     * 更新商铺信息,因为是单体项目所以将其放在同一个事务当中
     * @param shop
     * @return
     */
    @Override
    @Transactional
    public Result update(Shop shop) {
        Long id = shop.getId();
        if (id == null) {
            return Result.fail("店铺id不为空");
        }
        //先更新数据库
        updateById(shop);
        //再删除缓存
        stringRedisTemplate.delete(CACHE_SHOP_KEY + id);
        return Result.ok();
    }
```

### 缓存穿透

（恶意）请求缓存和数据库中都没有，缓存永远不会生效，跟透明的一样。

- 缓存空对象（对于恶意请求设置为空值`""`） 可能会存储大量空的数据，
- 布隆过滤：<img src="../Pic/image-20240406171035593.png" alt="image-20240406171035593" style="zoom:50%;" />有一定的穿透风险（因为多个元素哈希值可能映射到相同的位，出现假阳性）

代码解决缓存穿透：（选择缓存空对象思路）

<img src="../Pic/image-20240407082506163.png" alt="image-20240407082506163" style="zoom:50%;" />

```java
public Shop queryWithPassThrough(Long id) {
            String key = CACHE_SHOP_KEY + id;
            //1查询redis中的商铺缓存
            String shopJSON = stringRedisTemplate.opsForValue().get(key);
            //2存在直接返回
            if (StrUtil.isNotBlank(shopJSON)) {//isNotBlank这个方法意味着只有shopJSON有数据时才会返回true
                Shop shop = JSONUtil.toBean(shopJSON, Shop.class);
                return shop;
            }
            //从上面下来就剩两种情况：null或者空字符串(空值)
            if (shopJSON != null) {
                return null;//这里意味着是空字符串"",根据上面流程图空值就该结束。
            }
            //3redis中为null，根据id查询数据库
            Shop shop = getById(id);
            if (shop == null) {
                //4数据库中也没有，并且使用缓存空值来避免缓存穿透
                stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);//将空值写入redis当中
                return null;
            }
            //5存在写入redis并返回
            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);
            return shop;
        }
```

### 缓存雪崩

同一时段大量缓存中的KEY同时失效或者Redis服务宕机，大量请求直达数据库。

- 给KEY添加TTL随机值
- 使用Redis集群（微服务）
- 给业务添加降级限流，多级缓存。

### 缓存击穿（热点KEY）

**被高并发访问并且缓存重建业务复杂**的KEY失效了，会导致无数请求冲击数据库。

- 互斥锁——只有获取锁成功的线程才可以操作数据库和缓存；会导致等待过长，死锁风险。
- 逻辑过期——在value中添加*逻辑过期时间*（**不是TTL**），开启一个新线程帮自己进行数据库操作；其他线程**可以返回过期数据**<img src="../Pic/image-20240407085022109.png" alt="image-20240407085022109" style="zoom:50%;" />

#### 基于互斥锁代码实现

业务流程：

<img src="../Pic/image-20240407085651300.png" alt="image-20240407085651300" style="zoom:50%;" />

代码实现：利用redis中Spring结构的SETNX方法：`Set the value of a key,only if the key does not exist`

```java
public Shop queryWithMutex(Long id){
        String key = CACHE_SHOP_KEY + id;
        //1查询redis中的商铺缓存
        String shopJSON = stringRedisTemplate.opsForValue().get(key);
        //2存在直接返回
        if (StrUtil.isNotBlank(shopJSON)) {
            Shop shop = JSONUtil.toBean(shopJSON, Shop.class);
            return shop;
        }
        //需要判断命中是否为空值""
        if (shopJSON != null) {
            return null;
        }
        //如果redis中没有且不是空值，就要来操作数据库了
        //获取互斥锁，判断是否获取成功;失败则休眠并重试，成功根据id查询数据库写入Redis
        String lockKey = "" + id;
        Shop shop = null;
        try {
            boolean isLock = tryGetLock(lockKey);
            //
            if (!isLock) {
                //失败
                Thread.sleep(50);
                //休眠完后递归调用重新查询
                return queryWithMutex(id);
            }
            //如果获取锁成功，根据id查询数据库
            shop = getById(id);
            if (shop == null) {
                //4不存在报错，并且使用缓存空对象来避免缓存穿透
                stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);//将空值写入redis当中
                return null;
            }
            //5存在写入redis并返回
            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            //释放互斥锁
            unLock(lockKey);
        }

        return shop;
    }
```

#### 基于逻辑过期

业务流程：<img src="../Pic/image-20240407095734225.png" alt="image-20240407095734225" style="zoom:50%;" />

代码实现：（不管缓存穿透问题）

```java
    /**
     * 使用逻辑过期时间将Shop存入缓存redis中,即缓存重建过程代码
     * @param id 店铺id
     * @param expireSeconds 过期时间
     */
    public void saveShop2Redis(Long id, Long expireSeconds) throws InterruptedException {
        //查询店铺数据
        Shop shop = getById(id);
        Thread.sleep(200);
        //封装逻辑过期时间
        RedisData redisData = new RedisData();
        redisData.setData(shop);//工具类中的redisData对象，将shop作为其data
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));
        //写入redis
        stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));
        //并没有为这个数据设置TTL，这个过期时间是由我们手动在上面管理的
    }
```

正式逻辑代码：

```java
    //开启线程池
    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);
    /**
     * 使用逻辑过期时间来解决缓存击穿，不用考虑缓存穿透
     * @param id
     * @return
     */
    public Shop queryWithLogicalExpire(Long id) {
        String key = CACHE_SHOP_KEY + id;
        //1查询redis中的商铺缓存
        String shopJSON = stringRedisTemplate.opsForValue().get(key);
        //2不存在直接返回
        if (StrUtil.isBlank(shopJSON)) {
            return null;
        }
        //存在，需要判断是否过期
        //先把json反序列化为对象，拿出其中的逻辑过期时间判断是否过期
        RedisData redisData = JSONUtil.toBean(shopJSON, RedisData.class);//获取一个更广泛的从Redis中检索到的数据集，此例包含时间和对象
        JSONObject data = (JSONObject)redisData.getData();//拿到其中存储的数据，格式为JSON。真正的对象data即shop
        //拿到真正的shop对象和逻辑过期时间
        Shop shop = JSONUtil.toBean(data, Shop.class);
        LocalDateTime expireTime = redisData.getExpireTime();
        //未过期直接返回，已过期缓存重建
        if (expireTime.isAfter(LocalDateTime.now())){
            return shop;
        }
        //过期，先去获取互斥锁，失败返回店铺，成功开启线程执行重建并返回
        String lockKey = LOCK_SHOP_KEY + id;
        boolean isLock = tryGetLock(lockKey);
        if (isLock){
            //成功，独立线程缓存重建
            CACHE_REBUILD_EXECUTOR.submit(() ->{
                try {
                    this.saveShop2Redis(id, 30L);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                } finally {
                    //释放锁
                    unLock(lockKey);
                }
            });
        }
        //3redis中为null，根据id查询数据库
        //5存在写入redis并返回
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);
        return shop;
    }
```

### 缓存工具封装

将上述解决方案进行封装为工具。 

业务需求：<img src="../Pic/image-20240407170150304.png" alt="image-20240407170150304" style="zoom:50%;" />  

1+3；2+4

解决穿透实例：

```java
    /**
     * @param keyPrefix 前缀，需要用户传过来
     * @param id 根据id查数据库,也是泛型
     * @param type 告知将来要返回什么类型的数据
     * @param dbFallBack 用户传来的操作数据库的逻辑,函数式编程
     * @return
     * @param <R> 泛型，返回的对象类型不一定
     */
    public <R,ID> R queryWithPassThrough(String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallBack,
                                         Long time, TimeUnit timeUnit) {
        String key = keyPrefix + id;
        //1查询redis中的商铺缓存
        String json = stringRedisTemplate.opsForValue().get(key);
        //2存在直接返回
        if (StrUtil.isNotBlank(json)) {//isNotBlank这个方法意味着只有shopJSON有数据时才会返回true
            return JSONUtil.toBean(json, type);
        }
        //从上面下来就剩两种情况：null或者空字符串
        if (json != null) {
            return null;//这里意味着是空字符串"",
        }
        //3redis中为null，根据id查询数据库,但是工具类不知道如何查（因为类型不确定）
        R r = dbFallBack.apply(id);
        if (r == null) {
            //4数据库中也没有，并且使用缓存空对象来避免缓存穿透
            stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);//将空值写入redis当中
            return null;
        }
        //5存在写入redis并返回
        this.set(key, r, time, timeUnit);
        return r;
    }
```

## 秒杀业务

### 全局ID生成器

介绍：

订单表在数据库中没有使用自增ID，因为这样规律明显（用户可以推断）；所以订单ID不应该重复且无规律。

分布式系统下生成全局唯一ID的工具——当前业务内唯一，高可用，高性能，整体递增（有利于数据库操作），安全

<img src="../Pic/image-20240408085211372.png" alt="image-20240408085211372" style="zoom:50%;" />

一个时间戳里还有2的32次方个序列号。

代码实现：

```java
    /**
     * 生成全局唯一id，符号位+时间戳+序列号
     * @param keyPrefix 业务前缀，区分不同业务
     * @return
     */
    public long nextId(String keyPrefix){
        //生成时间戳:当前时间(秒）- 开始的时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timestamp =  nowSecond - BEGIN_TIMESTAMP;

        //生成序列号，利用redis的自增长,并拼接日期字符串，可以区分，统计某天的订单
        String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
        Long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);
        //拼接返回,因为返回的不是字符串而是long类型，所以需要进行移位拼接而不是简单的拼接。

        return timestamp << COUNT_BITS | count;//先将时间戳左移留出序列号位置，再使用或运算
    }
```

- 每天一个key可以保证不会超过32位的上限，并且可以统计当天的订单
- `increment()`用于对指定键的值进行自增操作
- 其中参数是键，redis会对这个键所对应的值（即序列号）进行自增。

### 实现优惠券秒杀下单

业务流程：

 优惠券分为平价券和特价券——特价券来自于平价券，但是多了一些信息（失效时间，库存等）

<img src="../Pic/image-20240408100437811.png" alt="image-20240408100437811" style="zoom:50%;" />

<img src="../Pic/image-20240408100856875.png" alt="image-20240408100856875" style="zoom:50%;" />

代码实现：

- 创建订单
- 扣除库存
- 需要判断秒杀是否开始结束，是否库存充足

```java
    @Resource
    private ISeckillVoucherService seckillVoucherService;//在优惠券下单的实现类中注入秒杀的的对象,用的是人家的方法

    @Resource
    private RedisIDWorker redisIDWorker;
    /**
     *
     * @param voucherId 秒杀券和普通券共享id
     * @return
     */
    @Override
    @Transactional//因为这段代码涉及了两张数据库表，一张扣减库存（优惠券表），一张更新订单（订单表）所以放在同一事务中
    public Result seckillVoucher(Long voucherId) {
        //1查询优惠券
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        //2判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            //
            return Result.fail("秒杀尚未开始");
        }
        //3判断秒杀是否结束
        if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
            //
            return Result.fail("秒杀已经结束");
        }
        //4判断库存是否充足
        if (voucher.getStock() < 1) {
            return Result.fail("库存不足");
        }
        //5扣减库存
        boolean success = seckillVoucherService.update().
                setSql("stock = stock - 1").
                eq("voucher_id", voucherId).update();
        if (! success){
            return Result.fail("库存不足");
        }
        //6创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        //订单id，用户id。代金券id
        long orderId = redisIDWorker.nextId("order");
        voucherOrder.setId(orderId);
        //
        Long userId = UserHolder.getUser().getId();
        voucherOrder.setUserId(userId);
        //
        voucherOrder.setVoucherId(voucherId);
        //订单写入数据库
        save(voucherOrder);

        return Result.ok(orderId);
    }
```

### 超卖问题  

多线程穿插并发问题，那么该如何加锁呢？

#### 悲观锁

<img src="../Pic/image-20240408105454182.png" alt="image-20240408105454182" style="zoom:50%;" />

加锁，串行效率低。

#### 乐观锁

<img src="../Pic/image-20240408105517977.png" alt="image-20240408105517977" style="zoom:50%;" />

不加锁，更新时执行判断（效率高）；**多用于更新数据**。

- 版本号法：每次更新要看版本号是否更改（如果真要更新也要同时更新版本号）<img src="../Pic/image-20240408105812189.png" alt="image-20240408105812189" style="zoom:50%;" />

- CAS法：Compare and Set，因为库存和版本号其实每次都是同步变化，所以可以只用库存来判断<img src="../Pic/image-20240408110147008.png" alt="image-20240408110147008" style="zoom:50%;" />

- 但乐观锁也有弊端，成功率太低：如果很多线程发现前面发生了更改，那么他们都会选择异常，但是业务中的更改并不代表着没有库存

解决失败率高的问题：

- 判断条件改为库存大于0即可，不用必须等于未修改时的值。
- 分段锁（分批加锁）

#### 代码实现

```java
        //5扣减库存并加上了乐观"锁"
        boolean success = seckillVoucherService.update().
                setSql("stock = stock - 1").//set stock = stock - 1
                eq("voucher_id", voucherId).gt("stock", 0)//where id = ? and stock > 0
                .update();//这里怎么把sql语句弄上了
```

使用了Mybatis-plus

### 一人一单功能

多了一个根据voucherId和userId判断是否已经下过单（订单是否存在）

<img src="../Pic/image-20240408112143716.png" alt="image-20240408112143716" style="zoom:50%;" />

同样会存在线程问题：**多个同样id的用户（一个号好几个人用）**访问导致刚开始都没有买过，一起买会造成一个用户买了很多票。

所以使用悲观锁。

```java
        Long userId = UserHolder.getUser().getId();
        synchronized (userId.toString().intern()) {
            return createVoucherOrder(voucherId);
        }
```

```java
    @Transactional
    public Result createVoucherOrder(Long voucherId) {
        //一人一单功能添加
        Long userId = UserHolder.getUser().getId();
        //对用户id添加悲观锁
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        if (count > 0) {
            //用户已经下过单了
            return Result.fail("用户已经购买过");
        }

        //5扣减库存并加上了乐观"锁"
        boolean success = seckillVoucherService.update().
                setSql("stock = stock - 1").//set stock = stock - 1
                        eq("voucher_id", voucherId).gt("stock", 0)//where id = ? and stock > 0
                .update();//这里怎么把sql语句弄上了
        if (!success) {
            return Result.fail("库存不足");
        }

        //6创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        //订单id，用户id。代金券id
        long orderId = redisIDWorker.nextId("order");
        voucherOrder.setId(orderId);
        //
        voucherOrder.setUserId(userId);
        //
        voucherOrder.setVoucherId(voucherId);
        //订单写入数据库
        save(voucherOrder);

        return Result.ok(orderId);
    }
```

### 分布式锁版本1：SETNX

Sychronized存在的问题：多个JVM，多个锁监视器（**集群模式时会存在多个JVM**）每个锁监视器只能监视自己的JVM中的线程。

#### 基本原理

<img src="../Pic/image-20240408160046373.png" alt="image-20240408160046373" style="zoom:50%;" />

<img src="../Pic/image-20240408161139624.png" alt="image-20240408161139624" style="zoom:50%;" />

#### 代码实现

- 获取锁（互斥）`SETNX`
- 释放锁`DEL`,为解决死锁，设置超时释放。`SET lock thread1 EX 10 NX`将获取锁与超时释放写在一条语句中
- 使用非阻塞式锁，一旦获取失败就返回不等待。
- **Redis分布式锁中key-value所表示的是锁的名称-锁的值**（标识持有锁的线程身份）

```java
public class SimpleRedisLock implements ILock{

    private static final String KEY_PREFIX = "lock:";

    //需要调用者传递锁的名称和stringRedisTemplate
    private StringRedisTemplate stringRedisTemplate;
    private String name;

    public SimpleRedisLock(StringRedisTemplate stringRedisTemplate, String name) {
        this.stringRedisTemplate = stringRedisTemplate;
        this.name = name;
    }

		
    @Override
    public boolean tryLock(long timeoutSec) {
        //获取线程标识
        long threadId = Thread.currentThread().getId();
        //获取锁
        Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId + "", timeoutSec, TimeUnit.SECONDS);
        return Boolean.TRUE.equals(success);//防止自动拆箱空指针问题
    }

    @Override
    public void unlock() {
      //释放锁
        stringRedisTemplate.delete(KEY_PREFIX + name);
    }
}

```

```java
//创建锁对象
SimpleRedisLock lock = new SimpleRedisLock("order:" + userId, StringRedisTemplate);
//
boolean isLock = lock.tryLock(1200);
//
if(!isLock){
  //获取锁失败
  return Result.fail("一个人只允许下一单");
}
try{
  //获取事务代理对象
  IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
  return proxy.createVoucherOrder(voucherId);
}finally{
  lock.unlock();
}
```

### 版本1加强

如果出现拥有锁的业务业务阻塞，锁会超时释放，其他线程拿到锁；但是当线程1业务完成时，会执行finally中的释放锁将其他线程的锁释放。

- 故释放锁时需要看一下是不是自己的锁
- <img src="../Pic/image-20240408164937619.png" alt="image-20240408164937619" style="zoom:50%;" />

代码实现

```java
//释放锁   
@Override
    public void unlock() {
        //判断锁是否是自己的，需要线程标识
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        //
        String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);
        if (threadId.equals(id)){
            //判断线程id是否与锁中的id一致
            stringRedisTemplate.delete(KEY_PREFIX + name);
        }
    }
```

 但是判断锁与释放锁之间也应该成为一个原子性问题。

#### Lua脚本

一个脚本中执行多条Redis命令，确保这些指令的原子性。

- `redis.call`如何写脚本
- `EVAL script`如何调用脚本
- redis需要指定参数key的个数——KEYS数组，AGRV数组，脚本中可以从数组中取这些参数。<img src="../Pic/image-20240409091714004.png" alt="image-20240409091714004" style="zoom:50%;" />

```lua
-- get得到的是当前key所对应的线程名称，与ARGV（当前线程标识）作比较
if(redis.call('get', KEYS[1]) == ARGV[1]) then
  --释放锁
  return redis.call('DEL', KEYS[1])
end
-- 不一致，直接返回。
return 0
```

JAVA调用Lua脚本

`public <T> T execute(RedisScript<T> script, List<K> keys, Object ...args){return scriptExecutor.execute(script, keys, args)}`

```java
    private static final DefaultRedisScript<Long> UNLOCK_SCRPIT;
    static {
        UNLOCK_SCRPIT = new DefaultRedisScript<>();
        UNLOCK_SCRPIT.setLocation(new ClassPathResource("unlock.lua"));
        UNLOCK_SCRPIT.setResultType(Long.class);
    }
//
    @Override
    public void unlock() {
        //调用lua脚本
        stringRedisTemplate.execute(UNLOCK_SCRPIT, Collections.singletonList(KEY_PREFIX + name),
                ID_PREFIX + Thread.currentThread().getId());
    }
```

### 分布式锁版本2Redisson

SETNX锁不可重入，不可重试，超时释放不合理，主从一致性（主节点与从节点同步）；故使用Redisson框架。

在Redis基础上实现分布式锁的实现。

使用`RedissonClient`代替`stringRedisTemplate`

```java
@Configuration
public class RedissonConfig {

    //将redisson客户端创建好交由spring管理
    @Bean
    public RedissonClient redissonClient(){
        //配置
        Config config = new Config();
        config.useSingleServer().setAddress("redis://127.0.0.1:6379").setPassword("123321");
        //创建Redisson对象
        return Redisson.create(config);
    }
}
```

也不需要自己写trylock和unlock方法，可以直接调用其api。

#### Redisson可重入锁原理

**同一线程无法多次获取一把锁**。

判断是否为同一线程，并设置重用次数。（使用Redis的Hash结构，没有SETNXEX）

源码原理：<img src="../Pic/image-20240409103630876.png" alt="image-20240409103630876" style="zoom:50%;" />

**使用Hash结构记录线程id和重入次数**

<img src="../Pic/image-20240409104758978.png" alt="image-20240409104758978" style="zoom:50%;" />

获取锁：

```java
boolean isLock = lock.tryLock(long waitTime, long leaseTime, TimeUnit timeUnit)
```

释放锁：

```lua

```

 这两段Lua脚本Redisson内部已经封装好了，只需要使用Redisson的方法就好了。

#### Redisson可重试、超时

获取锁只尝试一次就返回false，没有去重试。

源码原理：

<img src="../Pic/image-20240409151731912.png" alt="image-20240409151731912" style="zoom:50%;" />

- 使用信号量和PubSub功能等待释放锁的消息。（只要在时间之内）
- 利用watchDog，每隔一段时间，重置锁的超时时间（防止某些原因业务未完成就超时释放）

#### Redisson主从问题

 MutiLock使用多个独立的Redis节点，必须在所有节点都获取成功才算成功。

### Redis秒杀优化——异步

之前的操作都是串行执行，并且很多需要操作数据库，所以考虑将操作分组执行——先用Redis完成库存和一人一单的判断，完成抢单业务；再将下单业务放入阻塞队列，开启独立线程异步完成下单（创建订单）操作。

 <img src="../Pic/image-20240409155706013.png" alt="image-20240409155706013" style="zoom:50%;" />

将判断库存秒杀和校验一人一单放在一个Redis逻辑中：

<img src="../Pic/image-20240409160905594.png" alt="image-20240409160905594" style="zoom:50%;" />

**下单和减少库存只需要读取阻塞队列中的用户信息，就可以完成异步下单。**

业务需求：

<img src="../Pic/image-20240409161505612.png" alt="image-20240409161505612" style="zoom:50%;" />

代码实现：

- 添加秒杀券信息到Redis中    

```java
//
@Override
    @Transactional
    public void addSeckillVoucher(Voucher voucher) {
        // 保存优惠券
        save(voucher);
        // 保存秒杀信息
        SeckillVoucher seckillVoucher = new SeckillVoucher();
        seckillVoucher.setVoucherId(voucher.getId());
        seckillVoucher.setStock(voucher.getStock());
        seckillVoucher.setBeginTime(voucher.getBeginTime());
        seckillVoucher.setEndTime(voucher.getEndTime());
        seckillVoucherService.save(seckillVoucher);
        //保存秒杀库存到Redis当中
        stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());
    }
```

- 基于Lua脚本实现两个功能并判断用户是否抢购成功

```lua
---优惠券id，用户id
local voucherId = ARGV[1]
local userId = ARGV[2]
---数据key:库存，订单
local stockKey = 'seckill:stock:' .. voucherId
local orderKey = 'seckill:order' .. voucherId

--脚本业务
if(tonumber(redis.call('get', stockKey)) <= 0) then
    --库存不足，返回1
    return 1
end

--判断用户是否下单
if(redis.call('sismember', orderKey, userId) == 1) then
    --存在与list中，说明重复下单
    return 2
end

--否则就扣库存，并且下单
redis.call('incrby', stockKey, -1)
--下单（保存用户到list中）
redis.call('sadd', orderKey, userId)
```

- 执行脚本判断结果,并把结果封装在阻塞队列中。

```java
        //执行lua脚本,判断库存以及一人一单
{Long result = stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(),
                voucherId.toString(), userId.toString());
        //判断结果是否为0，如果为0才有购买资格
        int r = result.intValue();
        if (r != 0){
            return Result.fail(r == 1 ? "库存不足" : "不能重复下单");
        }
        //将下单信息保存在阻塞队列中
        VoucherOrder voucherOrder = new VoucherOrder();
        long orderId = redisIDWorker.nextId("order");//订单id
        voucherOrder.setId(orderId);
        //用户id
        voucherOrder.setUserId(userId);
        //秒杀券id
        voucherOrder.setVoucherId(voucherId);
        //加入阻塞队列
        orderTasks.add(voucherOrder);
}
    //阻塞队列,如果队列中没有，线程就会阻塞，有了才会获取。
    private BlockingQueue<VoucherOrder> orderTasks = new ArrayBlockingQueue<>(1024 * 1024);//存在内存限制问题，数据安全问题

```

- 开启线程任务，从阻塞队列中获取订单信息，异步下单

```java
    private static final ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();//新建线程池


//Handler在应用启动时就开始执行，并且会一直运行，等待处理队列中的订单。通过在@PostConstruct标记的方法中提交这个任务，你可以保证这个后台任务在Spring容器完成初始化后立即开始运行
    @PostConstruct
    private void init(){
        SECKILL_ORDER_EXECUTOR.submit(new VoucherOrderHandler());
    }
//
    private class VoucherOrderHandler implements Runnable{
        @Override
        public void run() {
            //
            while (true){
                try {
                    //获取队列中的订单信息，
                    VoucherOrder voucherOrder = orderTasks.take();
                    //创建订单
                    handleVoucherOrder(voucherOrder);
                } catch (Exception e) {
                    log.error("处理订单异常", e);
                }
            }
        }
    }
//
    private void handleVoucherOrder(VoucherOrder voucherOrder) {
        Long userId = voucherOrder.getUserId();//获取用户
        //下单
    }

```

`VoucherOrderHandler`是一个内部类，实现了`Runnable`接口，定义了一个无限循环，使得它可以不断地从某个队列（假设名为`orderTasks`）中获取订单信息`VoucherOrder`对象，并对每个订单执行`handleVoucherOrder(voucherOrder)`方法来进行处理。

### 消息队列改善阻塞队列

独立于JVM以外的服务，不受内存限制；做数据持久化，数据安全。Redis提供了三种自带的方法实现。

#### List

双向链表模拟**阻塞**队列。 

`BRPOP or BLPOP`来实现阻塞效果。

因为作为数据存储，所以肯定支持持久化；但只支持单消费者（一旦拿到就拿走了）

#### PubSub发布订阅

<img src="../Pic/image-20240410095900530.png" alt="image-20240410095900530" style="zoom:50%;" />

不支持持久化

#### Stream

发消息：返回的是消息的唯一标识

<img src="../Pic/image-20240410101329292.png" alt="image-20240410101329292" style="zoom:50%;" />

读消息：

<img src="../Pic/image-20240410102248828.png" alt="image-20240410102248828" style="zoom:50%;" />

消息队列-消费者组

多个消费者划分一组，一组监听同一个队列。

![image-20240410102702527](../Pic/image-20240410102702527.png)

 创建组：

<img src="../Pic/image-20240410103016752.png" alt="image-20240410103016752" style="zoom:50%;" />

组内读取消息：

<img src="../Pic/image-20240410103417855.png" alt="image-20240410103417855" style="zoom:50%;" />

确认消息

`XACK`确认中出现异常的消息（即已消费但未确认的消息），会加入到PendingList中。

PendingList

每个消费者都有自己的PendingList，来处理未确认的消息。

<img src="../Pic/image-20240410104836119.png" alt="image-20240410104836119" style="zoom:50%;" />

但是没有提到生产者的事情。需要用其他的框架技术。

业务需求

<img src="../Pic/image-20240410145719387.png" alt="image-20240410145719387" style="zoom:50%;" />

代码实现

`XGROUP CREATE stream.orders g1 0 MKSTREAM`创建消费者组，消息队列名称为`stream.orders`

```lua
--发送消息到队列中，XADD stream.orders * k1 v1 k2 v2
redis.call('xadd', 'stream.orders', '*', 'userId', userId, 'voucherId', voucherId, 'id', orderId)
```

修改JAVA代码中的逻辑
```java
    public Result seckillVoucher(Long voucherId) {
        //获取用户
        Long userId = UserHolder.getUser().getId();
        //订单id
        long orderId = redisIDWorker.nextId("order");
        //执行lua脚本,判断库存以及一人一单,并且将消息发送到消息队列中
        Long result = stringRedisTemplate.execute(SECKILL_SCRIPT, Collections.emptyList(),
                voucherId.toString(), userId.toString(), String.valueOf(orderId));
        //判断结果是否为0，如果为0才有购买资格
        int r = result.intValue();
        if (r != 0){
            return Result.fail(r == 1 ? "库存不足" : "不能重复下单");
        }
        //获取代理对象，为了让以后的子线程可以拿到
        proxy = (IVoucherOrderService) AopContext.currentProxy();
        //异步下单

        //返回订单id
        return Result.ok(orderId);
    }
```

修改之前阻塞队列为消息队列

```java
private class VoucherOrderHandler implements Runnable{
        String queueName = "stream.orders";
        @Override
        public void run() {
            //
            while (true){
                try {
                    //获取消息队列中的订单信息XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS streams.order >
                    List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(
                            Consumer.from("g1", "c1"),
                            StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),
                            StreamOffset.create(queueName, ReadOffset.lastConsumed())
                    );
                    //判断消息获取是否成功，如果获取失败继续下一次循环
                    if (list == null || list.isEmpty()){
                        continue;
                    }
                    //成功就创建订单
                    //先解析消息中的订单信息
                    MapRecord<String, Object, Object> record = list.get(0);
                    Map<Object, Object> values = record.getValue();//发消息时就是拿着key-value形式发的
                    VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(values, new VoucherOrder(), true);
                    handleVoucherOrder(voucherOrder);
                    //进行ack确认 SACK stream.orders g1 id 这个id是消息队列的id stream.order
                    stringRedisTemplate.opsForStream().acknowledge(queueName,"g1", record.getId());
                } catch (Exception e) {
                    log.error("处理订单异常", e);
                    //确认出现异常，就放到pendinglist中，再次处理
                    handlePendingList();
                }
            }
        }
    }
```

对Pendinglist中的订单进行再处理
```java
private void handlePendingList() {
        String queueName = "stream.orders";
        while (true){
            try {
                //获取Pending-List中的订单信息XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS streams.order >
                List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(
                        Consumer.from("g1", "c1"),
                        StreamReadOptions.empty().count(1),
                        StreamOffset.create(queueName, ReadOffset.from("0"))
                );
                //判断消息获取是否成功，如果获取失败继续下一次循环
                if (list == null || list.isEmpty()){
                    break;//说明pending-list中没有异常消息，需要结束循环
                }
                //成功就创建订单
                //先解析消息中的订单信息
                MapRecord<String, Object, Object> record = list.get(0);
                Map<Object, Object> values = record.getValue();//发消息时就是拿着key-value形式发的
                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(values, new VoucherOrder(), true);
                handleVoucherOrder(voucherOrder);
                //进行ack确认 SACK stream.orders g1 id 这个id是消息队列的id stream.order
                stringRedisTemplate.opsForStream().acknowledge(queueName,"g1", record.getId());
            } catch (Exception e) {
                //pendinglist中出现异常
                log.error("处理pendinglist异常", e);
            }
        }
    }
```

