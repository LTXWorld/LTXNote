# 739每日温度

## 题目要求

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

<img src="../../Pic/image-20240310090311507.png" alt="image-20240310090311507" style="zoom:50%;" />

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`

## 第一想法

暴力法来看，遍历温度数组，看后一个的数是否大于前面一个数，如果大于，前面数对应位置的结果位置置为1。（哦不对，天数不是紧邻地去看的，原来是好几天）如果小于的话继续往后比较，并且还要计数？但是如果移动到了后面的位置，被扫过的温度不就不能再去比较了？（否则每次往后开始遍历的时候还要设置一个变量来保存起始的位置？

直接去做很复杂，所以要使用单调栈？一个堆栈，按照温度数组顺序入栈，如果当前入栈元素大于栈顶元素，栈底元素出栈（这想的很美好，但是栈底元素怎么出栈啊），对应位置置为当前栈中元素数量；如果当前元素小于栈顶元素，就正常入栈；还是不对，如何处理71，69这些栈中的元素。

## 题解

### 本质

单调栈用来处理找元素左右第一个大于或者小于它的元素，并且最关键的是判断该栈是单调递增还是递减。

单调栈的作用是**存放之前遍历过的元素**。（这也解决了想法中的如何处理71,69这些遍历过的元素）

### 解决

根据题目条件，所求为天数（其实也是数组元素下标之间的距离），所以**将数组元素的下标放入栈中**，并且保证栈中顺序为递增，用以保证找到大于的元素。

每次比较都是在与栈顶元素比较：

- 如果小于，将比较元素继续入栈即可（可以做到存放之前遍历过的元素这一功能）
- 如果等于，同样放入。
- 如果大于，将栈顶元素出栈，将结果数组对应位置（栈顶元素即为下标）设置为下标之差；并且再继续与栈内元素（新的栈顶）去比较，如果还大于重复上述操作，如果不大于入栈即可。

### 代码实现

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int len = temperatures.length;
        int[] result = new int[len];//声明结果数组
        //声明单调栈,单调栈中保存原数组的下标
        Deque<Integer> stack = new LinkedList<>();
        stack.push(0);//将下标0入栈
        //开始遍历温度数组
        for (int i = 1; i < len; i++) {
            if (temperatures[i] <= temperatures[stack.peek()]){
                stack.push(i);
            }else {
                while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]){
                    //保证栈不为空并且现在的比较元素大于栈顶元素
                    result[stack.peek()] = i - stack.peek();//栈顶元素即需要赋值的下标位置，因为找到了第一个大于它的元素（的下标）
                    stack.pop();
                }
                stack.push(i);//如果不大于（或者栈已经为空了）需要将当前元素入栈，别忘记这一步。
            }
        }
        return result;
    }
}
```

# 496下一个更大元素I

## 题目要求

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

<img src="../../Pic/image-20240310101817049.png" alt="image-20240310101817049" style="zoom:50%;" />

## 第一想法

在上一道题目的身上套了一层皮，但是最终结果如果成功返回的是元素值本身，而不是元素之间的距离；如果还在单调栈中保存下标，最终结果中直接返回nums2[比较元素的下标]

所以将上面的单调栈方法封装为一个方法？但是又有所不同，可能不用遍历完整个nums2数组；每次都是找到一个待处理元素，将其放入栈中再去遍历2使用单调栈——即从特定元素开始寻找下一个更大的元素而不是每次都从头开始。

## 题解

反向思考一下，可以先在nums2中寻找到每一个元素的下一个更大元素（无需更改之前的单调栈代码），*对于nums2中的每一个元素找完后看看nums1中是否有相同的元素*，如果有相同的元素就要收集刚才的结果到结果集中

这时还有一个关键点是如何在nums1中从元素值找到对应下标（这与往常相反）——因为最终的结果集长度是根据nums1决定的，所以可以使用哈希表来反向映射nums1中的元素-下标关系。

### 代码实现

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        int len1 = nums1.length;
        int len2 = nums2.length;
        //声明结果数组与单调栈
        int[] result = new int[len1];
        Arrays.fill(result,-1);//根据题意初始化为-1
        //
        Deque<Integer> stack = new LinkedList<>();
        stack.push(0);
        //声明哈希表来保存nums1的反向映射关系
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < len1; i++) {
            map.put(nums1[i],i);//key(值）-value（下标）
        }
        //
        for (int i = 1; i < len2; i++) {
            if (nums2[i] <= nums2[stack.peek()]){
                stack.push(i);
            }else {
                while (!stack.isEmpty() && nums2[i] > nums2[stack.peek()]){
                    //如果此时2中的某个元素与1中相同（符合题意）
                    if (map.containsKey(nums2[stack.peek()])){
                        Integer index = map.get(nums2[stack.peek()]);
                        result[index] = nums2[i];//将2中下一个大的数填充结果数组
                    }
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return result;
    }
}
```

