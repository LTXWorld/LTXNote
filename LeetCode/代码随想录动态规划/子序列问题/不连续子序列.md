# 300最长递增子序列
## 题目要求

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

<img src="../../../Pic/image-20240301074930595.png" alt="image-20240301074930595" style="zoom:50%;" />

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

## 第一想法

子序列并不要求连续而只是要求递增，可以隔着进行选择，这个跟动态规划有什么关系吗？这种题目会有一个怎样的dp数组来表示什么样的含义呢？某个下标起始位置上的最长递增子序列吗？这样的序列会根据之后元素的顺序来确定？

## 题解

本题的实质是对于某个位置不断地与其前面的位置去比较，不断地比较从而推导出最大值。

### 五部曲

1、确定dp数组及其含义

- `dp[i]`代表着**以位置i为结尾**的元素最长的递增子序列

2、确定递推公式

- `if(nums[i] > nums[j]) dp[i] = max(dp[j] + 1, dp[i])`j在i之前，故位置i结尾的最长子序列不断地从前面的位置推出——**j从0到i-1各个位置的最长升序子序列 + 1 的最大值。**
- **注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值**。

3、确定初始化

- `dp[i] = 1`
- 注意，这里的初始化需要将每个位置都初始化为1，因为最起码本身元素算是一个长度。

4、确定遍历顺序

- 本题需要双层for循环，最外面的一层用来遍历每个位置i，内层的for循环用来遍历每个位置i前面的元素，从0到i-1的各个元素。

5、打印dp数组

- 最终的结果也发生了变化，不再是最后一个元素，因为dp数组的含义是以i为结尾的元素，所以我们需要在所有的dp数组值中找到一个最大值。
- 这个最大值可以在双层for循环中嵌入去寻找。

### 代码实现

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
      //先进行代码健壮性判断
        if(nums.length == 1){
            return 1;
        }
        //初始化dp数组
        int len = nums.length;
        int[] dp = new int[len];
        for(int i=0; i < len; i ++){
            dp[i] = 1;
        }
        int max = 0;
        //进行遍历
        for (int i = 1; i < len; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]){
                    dp[i] = Math.max(dp[j] + 1, dp[i]);//注意这里其实是在比较每个dp[j]+1
                }
                max = Math.max(max,dp[i]);
            }
        }
        return max;
    }
}
```

# 1143最长公共子序列

# 1035不相交的线