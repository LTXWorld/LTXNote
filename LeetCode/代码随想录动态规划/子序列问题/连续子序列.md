# 674最长连续递增序列

## 题目要求

给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

<img src="../../../Pic/image-20240301090254298.png" alt="image-20240301090254298" style="zoom:50%;" />

## 第一想法

本题与300最长递增子序列的区别是T300可以进行不连续选择，本题必须要求连续，但是上一题没有任何对于连续的要求，所以本题需要加什么特殊条件？

## 题解

不连续最长子序列第i位置的状态与前面所有位置上的元素都有关；而连续最长子序列第i位置上的状态只与前一个位置上的元素有关，这是两题最大的区别所在。

### 五部曲

`dp[i]`代表着以位置i元素为结尾的最长连续递增序列。

将五部曲中的递推公式进行更改即可，`if(nums[i] > nums[i-1] ) dp[i] = dp[i-1] + 1`；遍历顺序也不再需要双层for循环，因为只需要比较前一个位置。

### 代码实现

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        if (nums.length == 1) return 1;
        int len = nums.length;
        int[] dp = new int[len];
        for (int i = 0; i < len; i++) {
            dp[i] = 1;
        }
        int max = 0;
        //
        for (int i = 1; i < len; i++) {
            if (nums[i] > nums[i-1]){
                dp[i] = dp[i-1] + 1;
            }
            max = Math.max(max,dp[i]);
        }
        return max;
    }
}
```



# 718最长重复子数组

# 53最大子序和