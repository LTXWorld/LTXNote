# 142环形链表

## 题目要求：

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

## 思路：

### 第一想法：

- 怎么去找这个环，链表中只有一个环吗？

### 困难：

- 判断环
- 如何找到入口处

### 正解：

- 如果无环，快慢指针走完整个链表永远不可能相遇；如果有环，**在相对速度为1的前提下，二者一定会在环内相遇**。因为就像操场跑圈，相对速度1，快指针会一个一个地追，最终一定会追上。
- slow 走过的距离：x+y ; fast 走过的距离：x+y+n(y+z)* ;**进圈之后！！！这里慢指针不可能在圈里面走超过一圈，因为我们设定快指针速度是其两倍**，相同时间路程也是两倍，当慢指针马上走完一圈时，快指针一定都走了两圈了，早就相遇了！
- ![](C:\Users\ASUS\Pictures\Screenshots\屏幕截图_20230218_185907.png)

- 可以根据—**时间相同，速度一个1一个2，来列出二者路程的等式**——2(x+y) = x+y + n(z+y)——化简后得到**:x=(n-1)(z+y)+z**
- 可以发现当n=1时，即走到相遇点后快指针又绕了一圈与慢指针相遇了。x=z，故等式里的前面那一坨就是快指针多绕了多少圈罢了
- 根据x=z,在相遇点的指针和在起始的指针一起移动，一定会在环的入口处相遇。
- **找入口就可以定义一个在相遇处的指针，一个在起始位置的指针，二者相遇的点一定是入口。**

### 代码
```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        //根据思路，我们先设置快慢指针，一个速度为2一个为1
        ListNode fastNode = head;
        ListNode slowNode = head;
        //判断是否有环
        while(fastNode != null && fastNode.next != null){//因为快指针两步去走得看next
            fastNode = fastNode.next.next;
            slowNode = slowNode.next;
            //相遇之后说明有环
            if(slowNode == fastNode){
                //有环之后再去找入口,设置两个指针，一个在相遇点，一个在起始位置
                ListNode Node1 = fastNode;
                ListNode Node2 = head;
                while(Node1 != Node2){
                    //这时是公式里的x=z环节，速度是一样的
                    Node1 = Node1.next;
                    Node2 = Node2.next;
                }
                return Node1;
            }
        }
        //如果找不到环即退出返回null，其实找到环就一定会有入口的
        return null;
    }
}
```