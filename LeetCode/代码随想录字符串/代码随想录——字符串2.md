# 剑指offer05 替换空格

## 题目要求：

请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

```html
输入：s = "We are happy."
输出："We%20are%20happy."
```

## 第一想法：

这不是很简单嘛，遍历这个字符串，挨个地看哪个是空格，然后把它替换为%20就行。

## 困难：

- 坑爹啊，这个空格只占了一个字符位置，我得用charAt定位它，然后替换的时候要换成三个字符，这分明原始的字符串长度不够啊，不能这么简单地就去替换了，所以我得想办法新声明一个字符串或者一个字符数组来接收改变后的新的字符串。

- 我自己写的方法苦于最后无法将字符数组的长度截断，再转换为字符串。但是经过chatgpt的调教，我发现Arrays里面的copyof方法可以进行这一操作，只是要再重新申请一个数组，所以空间复杂度很高啊。具体代码如下：
```java
import java.util.Arrays;

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public String replaceSpace(String s) {
        /**
         * 如果我们只关注把空格替换的话，由于空格是一个
         * 字符，而%20是两个字符，所以我们需要新建一个
         * 字符数组来保存结果，最终将这个字符数组转换为字符串
         */
        char[] newchar = new char[3000];
        int len = s.length();
        int j = 0;
        for (int i = 0; i < len; i++) {
            if(!(s.charAt(i) == ' ')){
                newchar[j++] = s.charAt(i);
            }else {
                newchar[j++] = '%';
                newchar[j++] = '2';
                newchar[j++] = '0';
            }
        }
        char[] chars = Arrays.copyOf(newchar, j);
        //结束后将字符数组转换为字符串,但是不能返回整个。需要进行长度限制
        String s1 = new String(chars);
        return s1;
    }
}
```
## 正解

1. 我上面用字符数组去存储，也可以新建一个StringBuilder来存储，利用其动态的扩容机制以及强大的append方法直接进行替换即可。详情见代码一。
2. 使用前后双指针操作。

## 代码一
```java
    public String replaceSpace(String s) {
        /**
         * 如果我们只关注把空格替换的话，由于空格是一个
         * 字符，而%20是两个字符，所以我们需要新建一个
         * 字符数组来保存结果，最终将这个字符数组转换为字符串
         */
        if (s == null) {
            return null;
        }
        StringBuilder s1 = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == ' ') {
                s1.append("%20");
            } else {
                s1.append(s.charAt(i));
            }
        }
        return s1.toString();
    }
```
## 代码二

# 151翻转字符串中的单词

## 题目要求：

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用**至少一个空格**将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

```html
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
```

```html
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```

## 第一想法：

- 对于普通情况，我直接使用string自带的split方法对字符串进行按照空格划分，得到一个字符串数组里面就已经存好我要进行翻转的字符串了。翻转也很简单，前后两个指针往中间走就完事了。
- 如果遇到前导空格，
- 如果遇到两个单词之间不止一个空格进行划分，

## 困难：

- 对于后两种情况，好像无从下手，我觉得是应该先对于字符串进行预处理？比如前导空格存在的话怎么样去掉它；比如遇到中间多个空格，java使用next方法是不是有奇效？
- java的next方法好像能直接跨过空格接收啊，即使中间有很多空格他都会无视，直到遇到有效字符。至于前导空格也应该一样的嘛。
- 但是怎样利用next去填充整个你要的数组呢？
## 正解：

### 法1:

分三步走：

1. 进行对多余的空格进行删除
2. 反转整个字符串
3. 反转每一个单词。

### 法2:

- 在法一的基础上，删除空格时使用快慢指针完成，c而不需要额外地申请字符串空间。
- 具体想法设置快慢指针，快指针先往前走到非空格也就是单词处，然后慢指针目前不动，快指针不断向前走把字符复制给慢指针的位置，直到遇到空格说明这一个单词快指针处理完了。
- 为了让两个单词之间有一个空格，**慢指针往前走的候只要它不在起始位置就要在每次准备复制前给单词之间加上一个空格，这个非常关键。**
- 最后返回一个长度为slow的原字符串，因为是在原字符串上面操作的，所以空间复杂度为1

## 代码一：

还是使用到了Builder。

## 代码二：

对于这个法二我还是有一些没有理解的地方的，比如在快慢指针处理时，空格到底是抹去了还是覆盖了，还是其实是最后字符串后面全是空格，所以才重新申请了一个字符串来接受它。

并且在翻转单词的时候也要注意操作细节，小心空格以及边界条件。
```java
import com.sun.org.apache.xpath.internal.operations.String;

import java.util.Scanner;

//leetcode submit region begin(Prohibit modification and deletion)
class Solution {
    public String reverseWords(String s) {
        char[] chars = s.toCharArray();
        chars = removeExtraSpace(chars);
        reverse(chars,0,chars.length - 1);
        reverseWords(chars);
        return new String(chars);
    }
    //设计移除多余空格的方法，使用快慢指针，对字符数组进行操作。相当于在数组中移除值相同的元素了
    public char[] removeExtraSpace(char[] chars){
        int slow = 0;
        for (int fast = 0;fast < chars.length;fast ++){
            if(chars[fast] != ' '){
                //如果fast遇到空格，自动向后走，如果不是空格，就要进行对于单词的遍历操作
                //注意这里要用slow来添加空格
                if (slow != 0){
                    chars[slow ++] = ' ';
                }
                while (fast < chars.length && chars[fast] != ' '){
                    //当fast遇到了单词（字母）时，需要给slow的对应位置赋值
                    chars[slow ++] = chars[fast ++];
                }
            }
        }
        //这里为什么要新申请数组呢？还要把原来的数组截断，拷贝给他
        char[] chars1 = new char[slow];
        System.arraycopy(chars,0,chars1,0,slow);
        return chars1;
    }
    //翻转整个字符串
    public void reverse(char[] chars,int start,int end){
        if(end >= chars.length){
            return;
        }
        char tem =' ';
        while (start < end){
           tem = chars[end];
           chars[end] = chars[start];
           chars[start] = tem;
           start ++;
           end --;
        }
    }
    //翻转单词
    public void reverseWords(char[] chars){
        int start = 0;
        for (int end =0;end <= chars.length;end ++){
            //保证end在每一个单词的后一个位置
            if(end == chars.length || chars[end] == ' '){
                //如果遇到空格或者走到整个数组的最后，意味着要对某个单词进行翻转
                reverse(chars,start,end -1);
                start = end + 1;//start指向下一个单词的起始位置，+1是因为中间有一个空格
            }
        }
    }
}
```