# 55跳跃游戏

## 题目要求：

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

<img src="../../Pic/image-20240107083324495.png" alt="image-20240107083324495" style="zoom:50%;" />

```rust
1 <= nums.length <= 104
0 <= nums[i] <= 105
```
## 第一想法：
- 应该从失败的情况出发，只要元素不为0都是能够走到末尾的，但如果中间有元素为0了，那就存在无法到达的情况——其实就是无论怎么走都会落到0处，但是该如何刻画这个无论怎么走呢？示例二之所以会失败是因为第一步3已经能够涵盖掉后面的两步2，1了。
- 如何使用贪心呢？局部最优是跳到一个比自己大的数，这样会有更多的机会进行后续的选择？

## 题解：
### 思路一：覆盖范围
将本题的跳跃几步的思路转换为当前元素向后的覆盖范围有多大，只要最后可以覆盖到最后一个元素，就满足条件。
- 每次选取元素时，应在当前元素的覆盖范围内选取，并且选到的元素如果条件满足，可以不断地增加当前的覆盖范围（即覆盖范围每次会取一个最大值）
- 其实覆盖范围锚定的是数组的下标，只要其大于等于数组的最后一个位置即可。

```java
class Solution {
    public boolean canJump(int[] nums) {
        int coverIndex = 0;
        if (nums.length == 1) return true;
        for (int i = 0; i <= coverIndex ; i++) {
            coverIndex = Math.max(nums[i] + i,coverIndex);
            if (coverIndex >= nums.length - 1) return true;
        }
        return false;
    }
}
```

###思路二判断能否跨越0：
这个思路与第一想法贴合：遍历整个数组，遇到0的时候我们进行判断：
- 如果0前面的元素可以跨过0或者此时可以走到0且刚好0为最后一个元素，那么证明成立。（注意，即使0前面的元素有的跨不过，也不影响因为前面肯定都是正数，都能来到0前面的一个元素）
- 再具体一点就是只要0前一个元素能跨过0即可，中间的元素能跨过更好。

```java
class Solution {
    public boolean canJump(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0){
                //走到了0元素，需要对其前面的元素进行判断
                if (i == nums.length - 1) return true;
                //
                boolean canCross = false;
                for (int j = 0; j < i; j++) {
                    if (nums[j] > i-j ){
                        canCross = true;
                        break;
                    }
                }
                if (!canCross){
                    return false;
                }
            }
        }
        return true;
    }
}
```

# 45跳跃游戏II
## 题目条件
给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:

```
0 <= j <= nums[i]
i + j < n
```

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

```
1 <= nums.length <= 104
0 <= nums[i] <= 1000
```

题目保证可以到达 `nums[n-1]`

<img src="../../Pic/image-20240107091327868.png" alt="image-20240107091327868" style="zoom:50%;" />

## 第一想法：

本题的所求是最小跳跃数，即有一个次数的累计；并且题目条件也有所加强，不允许范围超出数组界限。那么要求这种最小的次数贪心是一定会做的，又回到股票问题了，你并不知道接下来哪一个跳跃（元素值）是最大且合理的，不能一直去等待峰值。

考虑这个次数能否等于跳跃范围的延伸次数，第一次延伸到3是一次，第二次扩展到4是第二次。（扩展到4就可以结束了）并且注意本题的提示，一定可以到达最后的位置。

- 所以更改上面的那段代码，每次获取coverIndex的时候，去判断即可——如果此次获取的coverIndex不大于上一次的，那么次数不会更改；如果此次获取的coverIndex大于上一次的，次数++

```java
class Solution {
    public int jump(int[] nums) {
        int coverIndex = 0;
        int pre = 0;//使用一个变量记录上一次的范围
        int result = 0;
        if (nums.length == 1) return 0;
        for (int i = 0; i <= coverIndex; i++) {
            pre = coverIndex;
            coverIndex = Math.max(i + nums[i] ,coverIndex);
            if (coverIndex > pre){
                result ++;
            }
            if (coverIndex >= nums.length - 1) break;
            if(nums[i] + coverIndex >= nums.length - 1) break;
        }
        return result;
    }
}
```

- 出现错误，发现还是想的太简单了，不仅仅是范围扩大的问题，<img src="../../Pic/image-20240107092939739.png" alt="image-20240107092939739" style="zoom:50%;" />

- 像这种样例，范围确实在一步步的扩大，但是其实只需要两步就可以来到终点，所以这个代码是否还需要一些额外的条件判断呢？比如范围扩大过程中如果当前范围可以直达终点了？
- <img src="../../Pic/image-20240107094940450.png" alt="image-20240107094940450" style="zoom:50%;" />增加了条件还是报错了。

## 题解：

### 方法一：贪心：

与第一想法不同的地方在于**我记录的是上一次的最大距离，而题解的贪心中记录的是下一次的最大距离**（作为后备能源）；还有一点不同在于为什么他每一个范围都尝试到了最后位置？？？

- 并且对于每一个覆盖范围都会尝试着走到覆盖范围的最后，当走到最后还没有走到终点，就意味着要使用下一次的最大范围了
- 除此之外还有一个条件判断是与我相同的，就是更新最大范围后要来看当前范围是不是已经可以来到终点了。

```java
class Solution {
    public int jump(int[] nums) {
        int coverIndex = 0;//当前覆盖范围的最远位置
        int nextCover = 0;//使用一个变量记录下一次的最大范围最远位置
        int result = 0;
        if (nums.length == 1) return 0;
        for (int i = 0; i < nums.length; i++) {//每一次的覆盖范围的终点是否已经到了最后位置
            nextCover = Math.max(i+nums[i],nextCover);
            if (i == coverIndex){//走到当前步的最远位置
                result ++;
                coverIndex = nextCover;
                if (nextCover >= nums.length-1) break;
            }
        }
        return result;
    }
}
```

- 注意，一开始的范围都是0，所以第一次就会进入if进行result++；然后才将范围更新为第一个元素，所以看似只加了一次。

# 452用最少数量的箭引爆气球

## 题目要求

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足 `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

<img src="../../Pic/image-20240113082723921.png" alt="image-20240113082723921" style="zoom:50%;" /><img src="../../Pic/image-20240113083350428.png" alt="image-20240113083350428" style="zoom:50%;" />

## 第一想法

模拟一下过程:示例一<img src="../../Pic/image-20240113083140034.png" alt="image-20240113083140034" style="zoom:50%;" />

所以跟y没有任何的关系，就是x横坐标的一个排列，看如何最大化的选取到每一个气球的横坐标范围之内。

- 贪心又该如何贪呢？可以发现示例二这种没有区间重叠的情况就得一个一个来，所以区间重叠是否是解决题目的关键？
- 我想先将二维数组按照第一个数即左边界进行从小到大的排序，然后观察区间的交叠现象，但接下来该如何处理呢？好像无从下手了。
- <img src="../../Pic/image-20240113083941576.png" alt="image-20240113083941576" style="zoom:50%;" />
- 6在1,2区间里面（最大限度保证12区间），11在23区间里面，这个11甚至都能取12；贪心应该就是贪的重叠部分的最远处。12区间重叠部分是2-6，最远为6；34区间重叠部分在10-12，三者都能取？
- 但是你怎么分的12区间，34区间为两对区间呢？23区间也有交集啊。所以贪心贪的到底是什么呢？有一些模糊的思路，但是代码写不出来。

## 题解

排序的思路是对的，如何判断重叠没有去想：

- 不重叠时：**第i个左边界大于i-1的右边界**
- 重叠：将不重叠条件取反即可，当前左边界小于等于上一个气球的右边界

此时注意，每次可不止两个区间重叠，应该还要继续往下判断是否还有第三个第四个都在此重叠区间内

- **更新最小右边界**
- 再去判断新的区间是否与下一个结点重叠（回到上面的重叠逻辑）

### 代码一：

具体流程即先去看与上一个是否重叠，不重叠结果+1；重叠更新右边界，拿着这个右边界去与下一个区间比较
- （其实现在比较难想的反倒是result++,按道理说这个解题的逻辑，result++是设置上一次不重叠的地方的弓箭，但其一开始就设置为了1（因为for从第二个开始的）又因为走到最后一个区间result没有++，所以也能理解）

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        //按照左边界排序
        Arrays.sort(points,(a,b) -> Integer.compare(a[0],b[0]));
        int result = 1;
        //
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > points[i-1][1]){
                result ++;
            }else {//如果发生了重叠，将此次重叠的区间的有边界进行更新，再去与下一个区间进行比较
                points[i][1] = Math.min(points[i-1][1],points[i][1]);
            }
        }
        return result;
    }
}
```

- 按照左边界排序的代码，比较数组的第一个元素（即左边界）从小到大升序排列。

# 435无重叠区间
