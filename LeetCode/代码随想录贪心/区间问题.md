# 55跳跃游戏

## 题目要求：

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

<img src="../../Pic/image-20240107083324495.png" alt="image-20240107083324495" style="zoom:50%;" />

```rust
1 <= nums.length <= 104
0 <= nums[i] <= 105
```
## 第一想法：
- 应该从失败的情况出发，只要元素不为0都是能够走到末尾的，但如果中间有元素为0了，那就存在无法到达的情况——其实就是无论怎么走都会落到0处，但是该如何刻画这个无论怎么走呢？示例二之所以会失败是因为第一步3已经能够涵盖掉后面的两步2，1了。
- 如何使用贪心呢？局部最优是跳到一个比自己大的数，这样会有更多的机会进行后续的选择？

## 题解：
### 思路一：覆盖范围
将本题的跳跃几步的思路转换为当前元素向后的覆盖范围有多大，只要最后可以覆盖到最后一个元素，就满足条件。
- 每次选取元素时，应在当前元素的覆盖范围内选取，并且选到的元素如果条件满足，可以不断地增加当前的覆盖范围（即覆盖范围每次会取一个最大值）
- 其实覆盖范围锚定的是数组的下标，只要其大于等于数组的最后一个位置即可。

```java
class Solution {
    public boolean canJump(int[] nums) {
        int coverIndex = 0;
        if (nums.length == 1) return true;
        for (int i = 0; i <= coverIndex ; i++) {
            coverIndex = Math.max(nums[i] + i,coverIndex);
            if (coverIndex >= nums.length - 1) return true;
        }
        return false;
    }
}
```

###思路二判断能否跨越0：
这个思路与第一想法贴合：遍历整个数组，遇到0的时候我们进行判断：
- 如果0前面的元素可以跨过0或者此时可以走到0且刚好0为最后一个元素，那么证明成立。（注意，即使0前面的元素有的跨不过，也不影响因为前面肯定都是正数，都能来到0前面的一个元素）
- 再具体一点就是只要0前一个元素能跨过0即可，中间的元素能跨过更好。

```java
class Solution {
    public boolean canJump(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0){
                //走到了0元素，需要对其前面的元素进行判断
                if (i == nums.length - 1) return true;
                //
                boolean canCross = false;
                for (int j = 0; j < i; j++) {
                    if (nums[j] > i-j ){
                        canCross = true;
                        break;
                    }
                }
                if (!canCross){
                    return false;
                }
            }
        }
        return true;
    }
}
```

# 45跳跃游戏II
## 题目条件
给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。

每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:

```
0 <= j <= nums[i]
i + j < n
```

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

```
1 <= nums.length <= 104
0 <= nums[i] <= 1000
```

题目保证可以到达 `nums[n-1]`

<img src="../../Pic/image-20240107091327868.png" alt="image-20240107091327868" style="zoom:50%;" />

## 第一想法

本题的所求是最小跳跃数，即有一个次数的累计；并且题目条件也有所加强，不允许范围超出数组界限。那么要求这种最小的次数贪心是一定会做的，又回到股票问题了，你并不知道接下来哪一个跳跃（元素值）是最大且合理的，不能一直去等待峰值。

考虑这个次数能否等于跳跃范围的延伸次数，第一次延伸到3是一次，第二次扩展到4是第二次。（扩展到4就可以结束了）并且注意本题的提示，一定可以到达最后的位置。

- 所以更改上面的那段代码，每次获取coverIndex的时候，去判断即可——如果此次获取的coverIndex不大于上一次的，那么次数不会更改；如果此次获取的coverIndex大于上一次的，次数++

```java
class Solution {
    public int jump(int[] nums) {
        int coverIndex = 0;
        int pre = 0;//使用一个变量记录上一次的范围
        int result = 0;
        if (nums.length == 1) return 0;
        for (int i = 0; i <= coverIndex; i++) {
            pre = coverIndex;
            coverIndex = Math.max(i + nums[i] ,coverIndex);
            if (coverIndex > pre){
                result ++;
            }
            if (coverIndex >= nums.length - 1) break;
            if(nums[i] + coverIndex >= nums.length - 1) break;
        }
        return result;
    }
}
```

- 出现错误，发现还是想的太简单了，不仅仅是范围扩大的问题，<img src="../../Pic/image-20240107092939739.png" alt="image-20240107092939739" style="zoom:50%;" />

- 像这种样例，范围确实在一步步的扩大，但是其实只需要两步就可以来到终点，所以这个代码是否还需要一些额外的条件判断呢？比如范围扩大过程中如果当前范围可以直达终点了？
- <img src="../../Pic/image-20240107094940450.png" alt="image-20240107094940450" style="zoom:50%;" />增加了条件还是报错了。

## 题解

### 方法一贪心

与第一想法不同的地方在于**我记录的是上一次的最大距离，而题解的贪心中记录的是下一次的最大距离**（作为后备能源）；还有一点不同在于为什么他每一个范围都尝试到了最后位置？？？

- 并且对于每一个覆盖范围都会尝试着走到覆盖范围的最后，当走到最后还没有走到终点，就意味着要使用下一次的最大范围了
- 除此之外还有一个条件判断是与我相同的，就是更新最大范围后要来看当前范围是不是已经可以来到终点了。

```java
class Solution {
    public int jump(int[] nums) {
        int coverIndex = 0;//当前覆盖范围的最远位置
        int nextCover = 0;//使用一个变量记录下一次的最大范围最远位置
        int result = 0;
        if (nums.length == 1) return 0;
        for (int i = 0; i < nums.length; i++) {//每一次的覆盖范围的终点是否已经到了最后位置
            nextCover = Math.max(i+nums[i],nextCover);
            if (i == coverIndex){//走到当前步的最远位置
                result ++;
                coverIndex = nextCover;
                if (nextCover >= nums.length-1) break;
            }
        }
        return result;
    }
}
```

- 注意，一开始的范围都是0，所以第一次就会进入if进行result++；然后才将范围更新为第一个元素，所以看似只加了一次。

# 452用最少数量的箭引爆气球

## 题目要求

有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足 `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。

<img src="../../Pic/image-20240113082723921.png" alt="image-20240113082723921" style="zoom:50%;" /><img src="../../Pic/image-20240113083350428.png" alt="image-20240113083350428" style="zoom:50%;" />

## 第一想法

模拟一下过程:示例一<img src="../../Pic/image-20240113083140034.png" alt="image-20240113083140034" style="zoom:50%;" />

所以跟y没有任何的关系，就是x横坐标的一个排列，看如何最大化的选取到每一个气球的横坐标范围之内。

- 贪心又该如何贪呢？可以发现示例二这种没有区间重叠的情况就得一个一个来，所以区间重叠是否是解决题目的关键？
- 我想先将二维数组按照第一个数即左边界进行从小到大的排序，然后观察区间的交叠现象，但接下来该如何处理呢？好像无从下手了。
- <img src="../../Pic/image-20240113083941576.png" alt="image-20240113083941576" style="zoom:50%;" />
- 6在1,2区间里面（最大限度保证12区间），11在23区间里面，这个11甚至都能取12；贪心应该就是贪的重叠部分的最远处。12区间重叠部分是2-6，最远为6；34区间重叠部分在10-12，三者都能取？
- 但是你怎么分的12区间，34区间为两对区间呢？23区间也有交集啊。所以贪心贪的到底是什么呢？有一些模糊的思路，但是代码写不出来。

## 题解

排序的思路是对的，如何判断重叠没有去想：

- 不重叠时：**第i个左边界大于i-1的右边界**
- 重叠：将不重叠条件取反即可，当前左边界小于等于上一个气球的右边界

此时注意，每次可不止两个区间重叠，应该还要继续往下判断是否还有第三个第四个都在此重叠区间内

- **更新最小右边界**
- 再去判断新的区间是否与下一个结点重叠（回到上面的重叠逻辑）

### 代码一

具体流程即先去看与上一个是否重叠，不重叠结果+1；重叠更新右边界，拿着这个右边界去与下一个区间比较
- （其实现在比较难想的反倒是result++,按道理说这个解题的逻辑，result++是设置上一次不重叠的地方的弓箭，但其一开始就设置为了1（因为for从第二个开始的）又因为走到最后一个区间result没有++，所以也能理解）

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        //按照左边界排序
        Arrays.sort(points,(a,b) -> Integer.compare(a[0],b[0]));
        int result = 1;
        //
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > points[i-1][1]){
                result ++;
            }else {//如果发生了重叠，将此次重叠的区间的有边界进行更新，再去与下一个区间进行比较
                points[i][1] = Math.min(points[i-1][1],points[i][1]);
            }
        }
        return result;
    }
}
```

- 按照左边界排序的代码，比较数组的第一个元素（即左边界）从小到大升序排列。

# 435无重叠区间

## 题目要求

给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。

<img src="../../Pic/image-20240114072318967.png" alt="image-20240114072318967" style="zoom:50%;" />

## 第一想法

跟上面那道题差不多，先按照左边界排好序，重叠的部分即当前区间的左边界小于上一个的右边界了。那怎么个移除记录法呢？去判断是否有重叠，如果与上一个区间重叠则总数++，并且要更新边界，这个更新边界的过程可以体现贪心，更新为重叠区间的最小右边界（防止后面的边界又被重叠导致需要移除的区间数目变多）

- 排序时如果出现左边界相同该怎么比，应该是按照右边界升序排列，那么sort里面需要添加什么吗？

## 题解

成功AC，所以这两道题十分相近，会其中一道就都明白了。

回答上面那个排序问题

- 当 `a[0]` 小于 `b[0]` 时，返回负数，意味着 `a` 应该在 `b` 之前。
- 当 `a[0]` 大于 `b[0]` 时，返回正数，意味着 `a` 应该在 `b` 之后。
- 当 `a[0]` 等于 `b[0]` 时，返回零。

当两个区间的左边界相同时（即 `a[0]` 等于 `b[0]`），`Integer.compare(a[0], b[0])` 返回零。在这种情况下，排序算法的行为取决于它是稳定的还是不稳定的：

- **稳定排序算法** 会保持这两个元素原有的相对顺序。也就是说，在数组中先出现的区间会保持在先出现的位置。
- **不稳定排序算法** 则不保证保持原有的相对顺序。

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        if (intervals.length == 1) return 0;
        Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0]));
        int result = 0;
        //
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] < intervals[i-1][1]){
                //当前左边界小于上一个的右边界，即有重叠部分
                result ++;
                //更新右边界
                intervals[i][1] = Math.min(intervals[i][1],intervals[i-1][1]);
            }//else即无重叠部分，继续进行遍历区间即可
        }
        return result;
    }
}
```

# 763划分字母区间

## 题目要求

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s`

返回一个表示每个字符串片段的长度的列表。

<img src="../../Pic/image-20240114074737725.png" alt="image-20240114074737725" style="zoom:50%;" />

<img src="../../Pic/image-20240114075011656.png" alt="image-20240114075011656" style="zoom:50%;" />

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成

## 第一想法

什么叫同一字母最多出现在一个片段中+尽可能多的分段：一种字母只能在一个区间里，满足这个条件下还要将区间分的尽可能的多。

<img src="../../Pic/image-20240114075222413.png" alt="image-20240114075222413" style="zoom:50%;" />

像示例2这种就是因为e和c在字符串的最后面和最前面，导致无法进行分段，所以每种字母的位置很重要，其实就是每一个字母的开始和结尾构成了一个区间，然后这些区间重叠在一起，我们这次不需要管重叠区间的事，要管的是最大能分多少个区间

- 示例一中abc三个区间重叠，a可以兜住bc，故可以在这里分段；
- 其实只要重叠了，我们就都得管；这次不仅要判断重叠，还要判断二者区间右边界的最大值，因为要兜得住其他兄弟的最远位置。

所以，对于所给的字符串s，我们先得将其转换为一个哈希表？键是对应的字母，值是起始位置这样一个数组。起始位置还得去遍历一遍s，还好长度500.（代码其实有点难写的，因为有字符串）

- 如何判断第一次出现还是最后一次出现呢？需要一个哈希表。

## 题解

不用这么复杂，最远位置的思考是对的，**只要遍历到最远出现位置就找到了分割线位置**，注意最后还要计算分割区间的长度，所以还要记录区间和结果。（left、right）

- 找最远位置也没有很复杂，遍历一遍每次遇到都记录下标即可，会不断被更远位置覆盖。
- 记录完最远位置后，再来一轮遍历找分割：每次右边界等于当前右边界和元素最远位置二者中的最大值,左边界在走到分割位置之后更新一次。

```java
class Solution {
    public List<Integer> partitionLabels(String s) {
        LinkedList<Integer> result = new LinkedList<>();
        int[] edge = new int[26];//哈希数组
        char[] chars = s.toCharArray();
        //使用数组作为哈希，记录最远出现位置下标
        for (int i = 0; i < chars.length; i++) {
            edge[chars[i]-'a'] = i;
        }
        //再遍历一趟来找到分割点，收获结果
        int left=0,right=0;
        for (int i = 0; i < chars.length; i++) {
            right = Math.max(edge[chars[i]-'a'],right);//不断更新右边界
            if (i == right){
                //直到找到能够兜住前面所有字母的最远位置
                result.add(i-left+1);
                left = i + 1;//左边界也要更新，开始下一段分割了
            }
        }
        return result;
    }
}
```

# 56合并区间

## 题目要求

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

<img src="../../Pic/image-20240115082143726.png" alt="image-20240115082143726" style="zoom:50%;" />

## 第一想法

还是一个套路，有重叠就去更新右边界，这次根据题目要求更新为最大值，左边界更新为最小值；如果无重叠就得去收获上一层的区间，将这个区间加入到最终结果集中。

- 但是如果从第二个数组出发，模拟一下示例1，走到15,18时才将8,10刚加入，而15,18却没有加入，所以代码实现的时候有问题，那遍历for循环时可以走到`intervals.length`处（会提示数组越界吗？）或者我可以判断当前是否走到最后一个了，走到最后一个时不仅要将前面的加入还要加入自己。

错误写法

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        ArrayList<int[]> result = new ArrayList<>();
        Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0]));
        int left = intervals[0][0];
        int right = intervals[0][1];
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] > intervals[i-1][1]){//意味着没有重叠
                result.add(new int[]{left,right});//这里每次直接的new数组加入也很巧妙
                left = intervals[i][0];
                right = intervals[i][1];//更新左右边界
            }else {
                //有重叠，更新右边界
                right = Math.max(intervals[i][1],right);
            }
        }
        //这里处理最后一个区间，解决了我们想法中的问题，走到最后一个区间时虽然没有加入结果但是已经更新了
        result.add(new int[]{left,right});
//        return result;需要进行一次类型转换
        return result.toArray(new int[result.size()][]);
    }
}
```

与前两个区间问题不同的是：错在了for循环中的if条件判断，不能单一的去只比较前后两个区间，在我们排序后应该去比较的是左边界>最大右边界

## 题解

### 方法一

排序后去比较**当前区间的左边界和当前整个的最大右边界**

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        ArrayList<int[]> result = new ArrayList<>();
        Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0]));
        int left = intervals[0][0];
        int right = intervals[0][1];
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] > right){//意味着没有重叠,注意这里的比较
                result.add(new int[]{left,right});//这里每次直接的new数组加入也很巧妙
                left = intervals[i][0];
                right = intervals[i][1];//更新左右边界
            }else {
                //有重叠，更新右边界
                right = Math.max(intervals[i][1],right);
            }
        }
        //这里处理最后一个区间，解决了我们想法中的问题，走到最后一个区间时虽然没有加入结果但是已经更新了
        result.add(new int[]{left,right});
//        return result;需要进行一次类型转换，注意使用toArray方法
        return result.toArray(new int[result.size()][]);
    }
}
```



### 方法二

为了好处理，将第一个区间先放入result中。每次进来比较的都是result结果集中最后一个进行比较，因为之前的区间已经被处理合并。

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        LinkedList<int[]> result = new LinkedList<>();
        Arrays.sort(intervals,(a,b) -> Integer.compare(a[0],b[0]));
        result.add(intervals[0]);
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i][0] <= result.getLast()[1]){
                int left = result.getLast()[0];
                int right = Math.max(intervals[i][1], result.getLast()[1]);
                result.removeLast();
                result.add(new int[]{left,right});
            }else {
                result.add(intervals[i]);
            }
        }
        return result.toArray(new int[result.size()][]);
    }
}
```

