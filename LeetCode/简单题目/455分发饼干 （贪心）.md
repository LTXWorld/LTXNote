# 455分发饼干 （贪心）

## 题目要求

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

## 思路

尽可能多的满足，那就想到贪心。但是我一开始没有想到排序，双指针倒是想到了。如果不先排序的话，你得每次去找那个最靠近胃口的尺寸，找到后还得置为0，然后对于下一个胃口又得来一遍。

先排好序，从后往前走，并且先走的肯定是胃口（根据题目要求）后走的是尺寸，且需要满足条件后才能往后走。所以大循环应该是胃口，里面使用if来判断条件，如果**使用while的话**会造成一种情况——连续满足同一胃口的尺寸会累加多次，但那个胃口只有一个人。

## 代码

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        /**贪心问题，先去将两个数组排序，然后从大的开始投喂，以达到最佳效率，不会浪费  */
        Arrays.sort(g);
        Arrays.sort(s);
        int ans=0;
        int len1 = g.length;
        int len2 = s.length;
        int j =len2-1;
        //应该先从胃口入手，因为题目要求是尽可能多的满足孩子,并且从后向前
        for(int i=len1-1;i>=0;i--){
            if(j>=0 && s[j] >= g[i]){//满足条件的大饼干给出去之后，饼干往前走
                ans++;
                j--;
                //错误的地方在于如果饼干中有两个连续满足胃口的，如第一个例子，ans会多加,所以使用if而不是while
            }
        }
        return ans;
    }
}
```