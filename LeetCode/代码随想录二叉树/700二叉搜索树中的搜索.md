# 700二叉搜索树中的搜索

## 题目要求

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null`

<img src="./../../Pic/image-20231217102304075.png" alt="image-20231217102304075" style="zoom:50%;" />

## 第一想法

利用二叉搜索树的特性，直接层序迭代暴力解决

递归如何写呢？

## 题解

### 迭代

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        /**
         * 二叉搜索树的特点是整棵树的左右孩子都要满足左小右大或者左大右小的原则。
         * 在找这个值的时候每次与根去比较就知道该往左还是该往右走
         * 递归还是迭代？，迭代模拟试试
         */
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.offer(root);
        while (! deque.isEmpty()){
            TreeNode node = deque.poll();
            if (node.val == val){
                return node;
            }else if (node.val < val){
                if (node.right != null) deque.offer(node.right);
                else return null;
            }else {
                if (node.left != null) deque.offer(node.left);
                else return null;
            }
        }
        return null;
    }
}
```

- 这样写太暴力了，代码也比较冗余，能否有一个更为简洁的写法——冗余的原因是使用了辅助队列，其实根据二叉搜索树的特点，可以不需要队列进行迭代。

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        //
        while (root != null){
            if (val < root.val) root = root.left;
            else if (val > root.val) root = root.right;
            else return root;
        }
        return null;
    }
}
```



### 递归

- 在递归时不必拘泥于怎样前中后序，更应该考虑的是二叉搜索树的特点。

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
       //递归如何写
        if (root == null || root.val == val){
            return root;//这算是递归的结束条件吗？
        }
        //进行递归，这里不必拘泥与怎么样遍历
        if (root.val > val){
            return searchBST(root.left, val);
        }else {
            return searchBST(root.right, val);
        }
    }
}
```

# 98验证二叉搜索树

## 题目要求

判断给出的树是否为二叉搜索树

## 第一想法

层序遍历对于每一层的根结点判断？

## 题解

