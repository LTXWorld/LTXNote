# 700二叉搜索树中的搜索

## 题目要求

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null`

<img src="./../../Pic/image-20231217102304075.png" alt="image-20231217102304075" style="zoom:50%;" />

## 第一想法

利用二叉搜索树的特性，直接层序迭代暴力解决

递归如何写呢？

## 题解

### 迭代

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        /**
         * 二叉搜索树的特点是整棵树的左右孩子都要满足左小右大或者左大右小的原则。
         * 在找这个值的时候每次与根去比较就知道该往左还是该往右走
         * 递归还是迭代？，迭代模拟试试
         */
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.offer(root);
        while (! deque.isEmpty()){
            TreeNode node = deque.poll();
            if (node.val == val){
                return node;
            }else if (node.val < val){
                if (node.right != null) deque.offer(node.right);
                else return null;
            }else {
                if (node.left != null) deque.offer(node.left);
                else return null;
            }
        }
        return null;
    }
}
```

- 这样写太暴力了，代码也比较冗余，能否有一个更为简洁的写法——冗余的原因是使用了辅助队列，其实根据二叉搜索树的特点，可以不需要队列进行迭代。

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        //
        while (root != null){
            if (val < root.val) root = root.left;
            else if (val > root.val) root = root.right;
            else return root;
        }
        return null;
    }
}
```



### 递归

- 在递归时不必拘泥于怎样前中后序，更应该考虑的是二叉搜索树的特点。

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
       //递归如何写
        if (root == null || root.val == val){
            return root;//这算是递归的结束条件吗？
        }
        //进行递归，这里不必拘泥与怎么样遍历
        if (root.val > val){
            return searchBST(root.left, val);
        }else {
            return searchBST(root.right, val);
        }
    }
}
```

# 98验证二叉搜索树

## 题目要求

判断给出的树是否为二叉搜索树

## 第一想法

层序遍历对于每一层的根结点判断？

## 题解

利用二叉搜索树的特点：**中序遍历出的结果是有序的**。

### 方法一：转为数组比较

```java
class Solution {
    private List<Integer> list = new ArrayList<>();
    public boolean isValidBST(TreeNode root) {
        /**
         * 中序遍历过程得到的序列是一个有序递增序列
         * 使用列表来记录结点判断其是否递增
         */
        list.clear();
        traverse(root);
        for (int i = 1; i < list.size(); i++) {
            if (list.get(i) <= list.get(i - 1)) return false;
        }
        return true;
    }
    private void traverse(TreeNode root){
        //其实这样对于每一个结点来说都是左中右这样的遍历方式,所以时间复杂度上去了。
        if (root == null) return;
        traverse(root.left);//左
        list.add(root.val);//中
        traverse(root.right);//右
    }
}
```

- 时刻保持着中序遍历的节奏；
- 时间复杂度高

### 方法二：递归遍历时比较I

- 这个方法比较难理解:使用了一个**max结点来记录上一次**中序遍历到的结点，为了保证中序的递增性，故要求max结点的值一定小于root（当前）结点的值。

```java
class Solution {
    private TreeNode max;//max代表着上一次遍历到的结点
    public boolean isValidBST(TreeNode root) {
        /**
         * 在递归的过程中直接比较
         */
        if (root == null) return true;//递归终止条件，空树也是二叉搜索树
        //对左子树进行判断
        boolean left = isValidBST(root.left);
        if (! left){
            return false;//如果直接写return left，那么后面的代码永远得不到执行。
        }
        if (max != null && root.val <= max.val) return false;//root代表着当前结点，当前结点要大于上一次结点
        max = root;
        //右
        boolean right = isValidBST(root.right);
//        if (! right){
//            return false;
//        }
        return right;//不是不如左边，而是最后是整个方法需要一个返回值且中序最后就是右边。
    }
}
```

- 注意对左右子树判断时的写法，前者不能直接`return left`,后者不能进行条件判断，因为右子树判断同时也是整个过程的最终。

### 方法二：递归遍历时比较II

- 上面的方法其实是为了避免此方法中申请的最大值不够小(还是上一次遍历得到的值）。
- 简单的中序遍历递归：

```java
class Solution {
    private long prev = Long.MIN_VALUE;//用来记录上一次遍历到的值
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        if (! isValidBST(root.left)) return false;
        if (root.val <= prev) return false;
        prev = root.val;
        return isValidBST(root.right);
    }
}
```

### 方法三：迭代

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        /**
         * 使用栈模拟中序递归过程，一路向左，然后中右处理每一个结点。都要保证有序性
         */
        if (root == null) return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;//记录上一次遍历到的结点
        while (root != null || ! stack.isEmpty()){
            while (root != null){
                stack.push(root);
                root = root.left;//将左边全部入栈
            }
            //中，处理
            TreeNode node = stack.pop();
            if (pre != null && node.val <= pre.val) return false;
            pre = node;
            //对当前结点node的右孩子进行处理
            root = node.right;
        }
        return true;
    }
}
```



# 530二叉搜索树中最小绝对差

## 题目要求：

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

## 第一想法：

- 转换为数组求？
- 他求的是任意结点之间诶；这道题目跟二叉搜索树有什么关系吗？

## 题解：

本题的唯一核心点，为什么跟二叉搜索树有关：我们知道，中序遍历下二叉搜索树为有序递增序列，**对于一个递增序列，最小差值只会出现在相邻结点之间**，不会出现在不相邻结点，因为A、B和C（其中A < B < C），B与A的差值和C与B的差值都不会大于C与A的差值

### 方法一：递归

- 中序遍历对于中的处理中找到相邻的最小差值。

```java
class Solution {
    private TreeNode prev;
    private int minValue = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        inorder(root);
        return minValue;
    }
    private void inorder(TreeNode root){
        if (root == null) return;
        inorder(root.left);
        //中，处理
        if (prev != null){
            minValue = Math.min(minValue,root.val - prev.val);
        }
        prev = root;//更新上一个结点
        inorder(root.right);
    }
}
```

### 方法二：迭代

普通中序栈迭代，其实跟二叉树的中序遍历迭代相同只是在处理结点时增添了特定的题目条件。

```java
class Solution {
    private TreeNode pre;
    Stack<TreeNode> stack;
    public int getMinimumDifference(TreeNode root) {
        //可以复习一下二叉树的第一节。
        if (root == null) return 0;
        stack = new Stack<>();
        TreeNode cur = root;
        int result = Integer.MAX_VALUE;
        while (cur != null || ! stack.isEmpty()){
            if (cur != null){
                //一路向左
                stack.push(cur);
                cur = cur.left;
            }else {//向左完后得回来处理中右
                cur = stack.pop();
                if (pre != null){
                    result = Math.min(result,cur.val - pre.val);
                }
                pre = cur;
                cur = cur.right;
            }
        }
        return result;
    }
}
```

