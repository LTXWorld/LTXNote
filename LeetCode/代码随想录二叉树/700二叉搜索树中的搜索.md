# 700二叉搜索树中的搜索

## 题目要求

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null`

<img src="./../../Pic/image-20231217102304075.png" alt="image-20231217102304075" style="zoom:50%;" />

## 第一想法

利用二叉搜索树的特性，直接层序迭代暴力解决

递归如何写呢？

## 题解

### 迭代

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        /**
         * 二叉搜索树的特点是整棵树的左右孩子都要满足左小右大或者左大右小的原则。
         * 在找这个值的时候每次与根去比较就知道该往左还是该往右走
         * 递归还是迭代？，迭代模拟试试
         */
        Deque<TreeNode> deque = new ArrayDeque<>();
        deque.offer(root);
        while (! deque.isEmpty()){
            TreeNode node = deque.poll();
            if (node.val == val){
                return node;
            }else if (node.val < val){
                if (node.right != null) deque.offer(node.right);
                else return null;
            }else {
                if (node.left != null) deque.offer(node.left);
                else return null;
            }
        }
        return null;
    }
}
```

- 这样写太暴力了，代码也比较冗余，能否有一个更为简洁的写法——冗余的原因是使用了辅助队列，其实根据二叉搜索树的特点，可以不需要队列进行迭代。

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        //
        while (root != null){
            if (val < root.val) root = root.left;
            else if (val > root.val) root = root.right;
            else return root;
        }
        return null;
    }
}
```



### 递归

- 在递归时不必拘泥于怎样前中后序，更应该考虑的是二叉搜索树的特点。

```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
       //递归如何写
        if (root == null || root.val == val){
            return root;//这算是递归的结束条件吗？
        }
        //进行递归，这里不必拘泥与怎么样遍历
        if (root.val > val){
            return searchBST(root.left, val);
        }else {
            return searchBST(root.right, val);
        }
    }
}
```

# 98验证二叉搜索树

## 题目要求

判断给出的树是否为二叉搜索树

## 第一想法

层序遍历对于每一层的根结点判断？

## 题解

利用二叉搜索树的特点：**中序遍历出的结果是有序的**。

### 方法一：转为数组比较

```java
class Solution {
    private List<Integer> list = new ArrayList<>();
    public boolean isValidBST(TreeNode root) {
        /**
         * 中序遍历过程得到的序列是一个有序递增序列
         * 使用列表来记录结点判断其是否递增
         */
        list.clear();
        traverse(root);
        for (int i = 1; i < list.size(); i++) {
            if (list.get(i) <= list.get(i - 1)) return false;
        }
        return true;
    }
    private void traverse(TreeNode root){
        //其实这样对于每一个结点来说都是左中右这样的遍历方式,所以时间复杂度上去了。
        if (root == null) return;
        traverse(root.left);//左
        list.add(root.val);//中
        traverse(root.right);//右
    }
}
```

- 时刻保持着中序遍历的节奏；
- 时间复杂度高

### 方法二：递归遍历时比较I

- 这个方法比较难理解:使用了一个**max结点来记录上一次**中序遍历到的结点，为了保证中序的递增性，故要求max结点的值一定小于root（当前）结点的值。

```java
class Solution {
    private TreeNode max;//max代表着上一次遍历到的结点
    public boolean isValidBST(TreeNode root) {
        /**
         * 在递归的过程中直接比较
         */
        if (root == null) return true;//递归终止条件，空树也是二叉搜索树
        //对左子树进行判断
        boolean left = isValidBST(root.left);
        if (! left){
            return false;//如果直接写return left，那么后面的代码永远得不到执行。
        }
        if (max != null && root.val <= max.val) return false;//root代表着当前结点，当前结点要大于上一次结点
        max = root;
        //右
        boolean right = isValidBST(root.right);
//        if (! right){
//            return false;
//        }
        return right;//不是不如左边，而是最后是整个方法需要一个返回值且中序最后就是右边。
    }
}
```

- 注意对左右子树判断时的写法，前者不能直接`return left`,后者不能进行条件判断，因为右子树判断同时也是整个过程的最终。

### 方法二：递归遍历时比较II

- 上面的方法其实是为了避免此方法中申请的最大值不够小(还是上一次遍历得到的值）。
- 简单的中序遍历递归：

```java
class Solution {
    private long prev = Long.MIN_VALUE;//用来记录上一次遍历到的值
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        if (! isValidBST(root.left)) return false;
        if (root.val <= prev) return false;
        prev = root.val;
        return isValidBST(root.right);
    }
}
```

### 方法三：迭代

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        /**
         * 使用栈模拟中序递归过程，一路向左，然后中右处理每一个结点。都要保证有序性
         */
        if (root == null) return true;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode pre = null;//记录上一次遍历到的结点
        while (root != null || ! stack.isEmpty()){
            while (root != null){
                stack.push(root);
                root = root.left;//将左边全部入栈
            }
            //中，处理
            TreeNode node = stack.pop();
            if (pre != null && node.val <= pre.val) return false;
            pre = node;
            //对当前结点node的右孩子进行处理
            root = node.right;
        }
        return true;
    }
}
```



# 530二叉搜索树中最小绝对差

## 题目要求：

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

## 第一想法：

- 转换为数组求？
- 他求的是任意结点之间诶；这道题目跟二叉搜索树有什么关系吗？

## 题解：

本题的唯一核心点，为什么跟二叉搜索树有关：我们知道，中序遍历下二叉搜索树为有序递增序列，**对于一个递增序列，最小差值只会出现在相邻结点之间**，不会出现在不相邻结点，因为A、B和C（其中A < B < C），B与A的差值和C与B的差值都不会大于C与A的差值

### 方法一：递归

- 中序遍历对于中的处理中找到相邻的最小差值。

```java
class Solution {
    private TreeNode prev;
    private int minValue = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        inorder(root);
        return minValue;
    }
    private void inorder(TreeNode root){
        if (root == null) return;
        inorder(root.left);
        //中，处理
        if (prev != null){
            minValue = Math.min(minValue,root.val - prev.val);
        }
        prev = root;//更新上一个结点
        inorder(root.right);
    }
}
```

### 方法二：迭代

普通中序栈迭代，其实跟二叉树的中序遍历迭代相同只是在处理结点时增添了特定的题目条件。

```java
class Solution {
    private TreeNode pre;
    Stack<TreeNode> stack;
    public int getMinimumDifference(TreeNode root) {
        //可以复习一下二叉树的第一节。
        if (root == null) return 0;
        stack = new Stack<>();
        TreeNode cur = root;//使用栈迭代就要设置工作指针指向当前结点
        int result = Integer.MAX_VALUE;
        while (cur != null || ! stack.isEmpty()){
            if (cur != null){
                //一路向左
                stack.push(cur);
                cur = cur.left;
            }else {//向左完后得回来处理中右
                cur = stack.pop();
                if (pre != null){
                    result = Math.min(result,cur.val - pre.val);
                }
                pre = cur;
                cur = cur.right;//右
            }
        }
        return result;
    }
}
```

# 501二叉搜索树中的众数

## 题目要求：

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。

## 第一想法

- 本题烦人的点在于众数不止一个，且函数返回值类型为数组类型
- 还是利用搜索树的中序有序？左中右这样去遍历，在中时进行条件的判断，如果上一个遍历的结点与当前相等？
- 众数在中序下只能是连着一起相等，至少两个；每次出现相等都要记录其频率？然后后面再遇到相等的去比较频率？最关键的是你得暂时记录这次相等的值吧，该怎么记录呢？

## 题解：

1. 关于暂时记录值与当前频率问题，可以使用哈希表

2. 确实如第一想法里第二条所说，我们比较前一个与当前即可，可以暂时将某个众数放入结果集当中；当他不是众数时再更新最大频率将其拿出结果集即可。

### 代码一：中序递归条件判断

- 同530一样，设置了prev来比较前后两次；有点不同的是**这道题先设置了prev为空，为了记录第一次的频率**。

```java
class Solution {
    private TreeNode prev = null;
    private int maxCount = 0;
    private int currentcount = 0;
    private List<Integer> result = new ArrayList<>();
    public int[] findMode(TreeNode root) {
        prev = null;
        maxCount = 0;
        currentcount = 0;//这里两次赋值是因为良好的编码习惯，其实赋值相同并不影响。
        result.clear();
        searchMode(root);
        //转换为数组输出
        int[] resultI = new int[result.size()];
        for (int i = 0; i < result.size(); i++) {
            resultI[i] = result.get(i);
        }
        return resultI;
    }
    private void searchMode(TreeNode cur){
        if (cur == null) return;
        //进行中序遍历
        searchMode(cur.left);
        //中，进行处理,三种情况，后两种多见
        if (prev == null){
            currentcount =1;//意味着第一个结点，还没有前一个结点
        }else if (prev.val == cur.val){
            currentcount ++;
        }else {
            currentcount = 1;//只记录这一次的当前频率
        }
        //将当前计数值与最大计数值比较
        if (currentcount == maxCount){
            result.add(cur.val);
        }
        if (currentcount > maxCount){
            maxCount = currentcount;
            result.clear();//清空之前的众数
            result.add(cur.val);
        }
        prev = cur;//千万别少了这重要的一步。
        //
        searchMode(cur.right);
    }
}
```

### 代码二:迭代

- 迭代的大体过程同530，在中右处理时加入题目自身逻辑即可。
- 注意最后将列表转换为数组的操作，*先将其流化，再将list流转变为int流（转变过程中用到了方法引用）最后将int流数组化*。

```java
class Solution {
    public int[] findMode(TreeNode root) {
        TreeNode prev = null;
        Stack<TreeNode> stack = new Stack<TreeNode>();
        List<Integer> result = new ArrayList<>();
        int maxCount = 0;
        int count = 0;
        TreeNode cur = root;
        while (cur != null || !stack.isEmpty()){
            //先一路向左
            if (cur != null){
                stack.push(cur);
                cur = cur.left;
            }else {//对中间结点进行操作
                cur = stack.pop();
                if (prev == null || prev.val != cur.val){
                    count = 1;
                }else {
                    count ++;
                }
                //
                if (count == maxCount){
                    result.add(cur.val);
                }else if (count > maxCount){
                    maxCount = count;
                    result.clear();
                    result.add(cur.val);
                }//if语句可以不写else的吗
                prev = cur;
                cur = cur.right;
            }
        }
        //最后将list列表转换为int数组,intvalue使用了方法引用更加简洁
        return result.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

- 哦原来if条件判断即使后面有`else if`也可以最后不写`else`的啊，只要所有情况已经覆盖完了。
