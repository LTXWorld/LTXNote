# 242有效的字母异位词

## 题目要求

给定两个字符串 `*s*` 和 `*t*` ，编写一个函数来判断 `*t*` 是否是 `*s*` 的字母异位词。

**注意：**若 `*s*` 和 `*t*` 中每个字符出现的次数都相同，则称 `*s*` 和 `*t*` 互为字母异位词。

## 思路：

### 第一想法：

没想到能够直接采用数组完成，没有用到Java里的哈希函数什么的，因为目前还没有学到哈希的使用。

### 正解：

哈希这个知识点，一般通过数组、set、map来解决。本题样本较少，使用数组更好，以空间换时间。时间复杂度是遍历的n。

### 代码

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        //我知道是使用哈希表，java里的哈希表咋写呢？目前还没学到这里
        //但是这道题可以不用哈希函数，只使用数组就能完成。


        //创建数组空间用来进行哈希，长度为26代表26个字母在s中出现的次数，初始默认为0
        int[] arr = new int[26];
        //数组的下标作为26个字母的出现次序，位置是相对的，用某个字母-a作为下标。a自然就是0
        for(int i = 0;i < s.length(); i++){
            //对这个记录数组进行填充，下标是某字母-'a'的ASCII码
            arr[s.charAt(i) - 'a'] ++;
        }
        /**记录完s中字母出现次数之后，遍历t，每次遍历在对应下标处的值-1，最终如果新数组全
        为0，则说明二者各个字母出现次数相同。只要有一个值不为0，则返回false */
        for(int i =0; i < t.length(); i++){
            arr[t.charAt(i) -'a'] --;
        }
        //增强for循环
        for(int count : arr){
            if(count != 0){
                return false;
            }
        }
        return true;
    }
}
```

### 二刷

- 没有想到能够利用相对ANSCI码来存储每一个小写字母的出现频率

# 49字母异位词分组：

## 题目要求：

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

```rust
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

## 思路一：（错误版）

- 自己根据上面判断是否为字母异位词所构思的一种思路，但是对于最关键的遍历判断以及如何输出想不通。（这也是为什么后面我们使用了hashmap）

- ```
  * 可以观察到返回的类型是一个二维的list数组
  * 将互相为字母异位词的字符串组合在一个list当中
  * 写一个方法来判断互相是否为字母异位词？
  * 遍历地去判断strs里面的所有字符串？如果互为字母异位词就？
  * 如何操作进入一个二维的list数组中呢？
  ```

## 代码一：（尝试版）：

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        /**
         * 可以观察到返回的类型是一个二维的list数组
         * 将互相为字母异位词的字符串组合在一个list当中
         * 写一个方法来判断互相是否为字母异位词？
         * 遍历地去判断strs里面的所有字符串？如果互为字母异位词就？
         * 如何操作进入一个二维的list数组中呢？
         */
        for (int i = 0; i < strs.length; i++) {
            if (strs[i] )
        }
    }
    public boolean Mutual(String s,String l){
        int[] result = new int[26];
        for (int i = 0; i < s.length(); i++) {
            result[s.charAt(i) - 'a'] ++;
        }
        for (int i = 0; i < l.length(); i++) {
            result[l.charAt(i) - 'a'] --;
        }
        for(int count : result){
            if (count != 0){
                return false;
            }
        }
        return true;
    }
}

```

## 思路二：（GPT字符计数版）

- 在思路一的基础上进行了更改，思路一是记录每个字符的出现次数，思路二借用这一点，通过创建键为字符计数字符串，值为字符串数组（列表）的`Hashmap`，因为这样一个字符计数字符串是独一无二的，例如`a2b1`意为：`aab`,所以最后返回对应的值即可。
- 使用哈希表的好处是能够有效地组织和检索数据，**尤其是在需要按某种方式对数据进行分组时**

## 代码二：（正确版）

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        //健壮性判断
        if (strs == null || strs.length == 0) return new ArrayList<>();
        //创建哈希表
        Map<String, List<String>> map = new HashMap<>();
        //记录每个字符的出现次数
        int[] count = new int[26];
        //依次来处理所给的字符串
        for(String s : strs){
            //每次计数前都要清空这个count数组
            Arrays.fill(count,0);
            for(char c : s.toCharArray()){
                count[c - 'a'] ++;//计数
            }
            //创建基于字符计数的键
            StringBuilder sb = new StringBuilder("");
            for (int i = 0; i < count.length; i++) {
                //遍历字符串出现的次数数组，组合为键
                if (count[i] > 0){
                    sb.append((char)('a' + i));//将字符一个一个加入到键中
                    sb.append(count[i]);//出现次数也要加入
                }
            }
            //将StringBuilder转换为字符串
            String key = sb.toString();
            if (!map.containsKey(key)){
                //如果map中不存在这个键，就往map里面添加这个键所对应的新列表
                map.put(key,new ArrayList<>());
            }
            //不论怎样，都将当前字符串添加到键所指向的字符串列表中
            map.get(key).add(s);//get得到的是一个键所对应的值即ArrayList列表，然后将字符串加入到这个对应的列表中
        }
        return new ArrayList<>(map.values());//返回一个一维+一维数组即二维数组
    }
}
```

### 回顾知识点：

- 哈希表HashMap