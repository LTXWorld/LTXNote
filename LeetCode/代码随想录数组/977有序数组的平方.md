# 977有序数组的平方

## 题目要求：

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 1：**

```java
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

## 思路

### 第一想法：

- 先用sqrt给每个元素都进行平方，然后再对无序数组排序不就好了。

### 困难：

自己经过考研只知道大概有9种排序手段，但是却一个都写不出来。

### 正解一：

正常平方之后进行排序，这里我使用了直接选择排序（也是数据结构复习里第一种排序，其中细节还是蛮多。）

时间复杂度根据不同排序方法各有差别，直接插入排序两层for循环为O(n平方)

### 代码一：
```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        //方法一：先将数组中元素全部平方，再对新数组进行排序
        //Java中平方函数为sqrt()
        int len = nums.length;
        for(int i = 0; i < len; i ++){
            nums[i] *= nums[i];//进行平方
        }
        //如何对一个无序数组进行排序排成非递减有序数组,ds里学过很多排序方法
        //直接插入排序，简单选择排序，快排等等。写个直接插入排序试一下。
        Insertsort(len , nums);
        return nums;
    }
    public void Insertsort(int n , int[] nums){
        int i,j;
        for( i = 1; i < n; i++){
            //在前面有序部分寻找插入位置
            int x = nums[i];
            for(j = i-1;j >= 0; j --){//在有序部分中逆序寻找插入的位置
                if(x < nums[j]){//这里必须是x注意别写成了nums[i]
                    nums[j+1] = nums[j];//将有序的部分向后移动挪位置
                }else{
                    break;
                }
            }
            nums[j+1] = x;//
        }
    }
}
```

### 正解二：

- 使用双指针法，因为**平方后最大值一定在数组的两边**，所以要排成非递减数组，可以设置一个新数组，指针指向其末尾；对于原数组设置头尾两个指针，移动前先比较两个值，大的放在新数组当中并且对应位置指针移动。

### 代码二：

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        //方法二，双指针相向移动
        int len = nums.length;
        //创建一个新数组来保存最终结果
        int[] res = new int[len];
        //创建双指针
        int left = 0,right = len - 1;
        //创建新数组的尾指针
        int end = len - 1;
        //开始比较移动
        while(left <= right){//都是闭区间
            if(nums[left] * nums[left] < nums[right] * nums[right]){
                //如果左边的小，右边的数值就放到新数组当中，并且向左移动
                res[end --] = nums[right] * nums[right];
                right --;
            }else{
                res[end --] = nums[left] * nums[left];
                left ++;
            }
        }
        return res;//这个时间复杂度是N，空间复杂度也是N
    }
}
```

## 总结：

- 方法一是常规方法，语言自带的库函数能够直接排序，但是如果让我自己写一些排序的话，比如这里的直接插入，快速排序还是不能够信手捏来，所以平时对于这些排序的学习还要加强。
- 方法二是规律性方法，得先看出最大值一定在两边出现，然后利用双指针去不断逼近比较，但是有可能去想为什么里面的值能保证不会出现一个较大值，**因为题干条件是原始数组是非递减的**。

