# 332重新安排行程

## 题目要求：

给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

- 例如，行程 `["JFK", "LGA"]` 与 `["JFK", "LGB"]` 相比就更小，排序更靠前。

假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

<img src="../../Pic/image-20240102082851945.png" alt="image-20240102082851945" style="zoom:50%;" />

```
tickets[i].length == 2
fromi.length == 3
toi.length == 3
```

`fromi` 和 `toi` 由大写英文字母组成

```
fromi != toi
```

## 第一想法：

从tickets里面可以获悉整个的行程结构，tickets内部的集合标记了每一次的出发点和终点，最终需要的是行程的组合（一个字典排序下最小的组合）

- 什么是字典排序啊？哈希？
- 这道题跟回溯有什么关系？难道是因为可能一个结点存在多种路径？要去进行判优？
- 本题的处理逻辑是什么该从哪里下手？大写的英文字母？感觉也得不到回溯的树型结构。但是从示例2可以看出本题的一个直观感受是先得到所有的有效路径，然后再根据字典排序得到最小路径。
- 本题的唯一好处就是告知了每次必须从JFK出发，那么先从tickets里面找到JFK，然后分叉（也就成为了不同的路径，诶突然想到其实在分叉的时候可以进行剪枝，直接去比较JFK后面的大小决定下一个不就最小了？）；到了下一个结点又是同样的逻辑（有点小疑问如何确定当前的路径不会断掉呢？）；最终可以发现有效路径都会将整个边用完。（注意条件，**所有机票必须都用且只能用一次**）；所以如何知道机票只用了一次呢，还要设置used数组来标识吗？
- 如果用回溯法的模板去想，结束条件应该是所有机票都被使用过一次，可以理解为所有内部列表都被遍历过？for循环对于每一层结点进行处理，将当前结点的下一个（？）加入到path中？如果是收集全部可能就不需要回溯了，所以处理结点时一定是有条件判断的。

## 题解：

<img src="../../Pic/image-20240102084458613.png" alt="image-20240102084458613" style="zoom:50%;" />

- 首先，本题是一个深度优先搜索下的回溯问题：结束条件又比较取巧，路径中的城市数量总是比机票数量多一个，利用这个条件来结束；
- 解释题目的字典排序：其实就是按照字母的顺序对字符串进行排序，如何实现题目中所要求的字典排序：两种方法（根据这两种方法我们分出两种代码解决方法，注意第一种会超时）
	- 直接对每张机票进行排序，排序的规则是对目的地进行排序
	- 使用Map进行映射

### 代码一：直接排序

```java
class Solution {
    private LinkedList<String> path = new LinkedList<>();
    private LinkedList<String> res ;
    public List<String> findItinerary(List<List<String>> tickets) {
        Collections.sort(tickets,(a,b) -> a.get(1).compareTo(b.get(1)));//先对机票进行了排序，ab代表两张不同的机票比较目的地？
        path.add("JFK");//必须以JFK开头
        boolean[] used = new boolean[tickets.size()];
        backtracking(new ArrayList<>(tickets),used);//注意这里要进行强制类型转换
        return res;
    }
    private boolean backtracking(ArrayList<List<String>> tickets, boolean[] used){
        if (path.size() == tickets.size() + 1){
            res=new LinkedList(path);//可以这样直接把path加进来吗？
            return true;
        }

        for (int i = 0; i < tickets.size(); i++) {
            if (!used[i] && tickets.get(i).get(0).equals(path.getLast())){
                //如果当前机票没被使用过且当前机票的起始地和路径中的最后一个城市相同，证明可以使用
                path.add(tickets.get(i).get(1));//将当前机票的目的地加入到路径中
                used[i] = true;
                //其实这里递归为什么要使用if判断比较疑惑：每次递归会判断是否可以结束。
                if (backtracking(tickets,used)){
                    return true;
                }
                //走到这里证明此路不通，需要回溯
                used[i] = false;
                path.removeLast();
            }
        }
        return false;
    }
}
```

- 在示例一中，此代码居然没有一次走到回溯的地方，每次递归回来都要从头开始去判断每一张机票是否满足条件，显然这样的时间复杂度太高了。

- 额外注意在实际项目中如何声明一个二维的list集合：

- ```java
  List<List<String>> tickets = Arrays.asList(
          Arrays.asList("JFK", "SFO"),
          Arrays.asList("JFK", "ATL"),
          Arrays.asList("SFO", "ATL"),
          Arrays.asList("ATL", "JFK"),
          Arrays.asList("ATL", "SFO")
  );//这tm是什么创建方式？
  ```

- `Arrays.asList`返回的是一个`java.util.Arrays$ArrayList`,是一个私有静态类，不能进行强制类型转换为`ArrayList`(因为它不是其实例)

### 代码二：使用Map映射

- 使用Map的原因也很简单，降低时间复杂度。
- 使用HashMap的思路也发生变化，使用了目的机场所对应的航班次数作为字典排序标准。（详情见注释）

```java
class Solution {
    //记录从出发机场到 到达机场的航班次数
    private Map<String,Map<String,Integer>> targets = new HashMap<>();
    public List<String> findItinerary(List<List<String>> tickets) {
        for (List<String> ticket : tickets){
            //初始化整个targets映射，使用TreeMap完成字典排序（红黑树）
            targets.computeIfAbsent(ticket.get(0), k -> new TreeMap<>());
            //获取出发机场所对应的那个map
            Map<String,Integer> map = targets.get(ticket.get(0));
            //对刚获取的map进行初始化，记录目的地及其航班个数
            map.put(ticket.get(1),map.getOrDefault(ticket.get(1),0) + 1);
        }
        LinkedList<String> path = new LinkedList<>();
        path.add("JFK");
        backtraking(tickets.size(),path);
        return path;
    }

    /**
     *注意此方法并不是在每个叶子结点上获取结果，最终结果只在一个叶子上，
     * 所以只要找到合适的路径就返回true，也是为什么使用了boolean而不是void的原因
     * @param ticketNum 机票数目
     * @param path 当前路径而不是初始的机票列表
     * @return
     */
    private boolean backtraking(int ticketNum,LinkedList<String> path){
        if (path.size() == ticketNum + 1) return true;
        //从当前路径中取出最后一个即上次的到达机场，这次的出发机场
        String last = path.getLast();
        //得到这次出发机场  所对应的  目的机场与航班次数的map映射
        Map<String,Integer> targetMap = targets.getOrDefault(last,new HashMap<>());
        //遍历这个map映射
        for (Map.Entry<String,Integer> target : targetMap.entrySet()){
            int count = target.getValue();//得到此时这条路线的航班次数
            if (count > 0){
                path.add(target.getKey());
                target.setValue(count - 1);//

                if (backtraking(ticketNum,path)){
                    return true;//每次递归去判断是否达到了结束条件
                }
                //回溯
                path.removeLast();
                target.setValue(count);//?
            }
        }
        return false;
    }
} //（二刷时记得debug）
```

