# 78子集

## 题目要求：

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

<img src="E:\GitT\Pic\image-20231229155135538.png" alt="image-20231229155135538" style="zoom:50%;" />

## 第一想法：

- 对于空集我先将其撇一边，这也是一个需要很多的for循环的问题，自然是回溯；但与之前的组合和切割一样吗？
- 回溯的模板，结束条件即叶子节点，取一个元素也算结束，两个也算结束这怎么样判断结束呢？感觉不只是遇到叶子节点才结束啊，遇到其他的中间符合条件的结点也会结束；参数需要数组、起始位置；每一层的for循环，如何处理节点？我觉得不符合条件的关键在于出现了重复。
- 提示方法中有位运算，怎么说？

## 题解：

<img src="./../../Pic/image-20231229162353484.png" alt="image-20231229162353484" style="zoom:50%;" />

与组合和切割问题最大的不同在于何处收集结果，**在每一层的for循环上都要进行结果的收集**。所以代码的整体结构也会出现变化。

- 以往都是在结束条件里收集结果，现在变成for循环中收集结果；且最终将结果的收集位置也要注意。

```java
class Solution {
    private List<Integer> path = new ArrayList<>();
    private List<List<Integer>> result = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        backtracking(nums,0);
        return result;
    }
    private void backtracking(int[] nums,int startIndex){
        //每次进入递归都先将上一次收集到的路径加入到结果中
        result.add(new ArrayList<>(path));
        //结束条件当每层的起始位置startIndex到最后即叶子节点
        if (startIndex >= nums.length){
            return;
        }
        for (int i = startIndex; i < nums.length ; i++) {
            //收集结果在这里执行
            path.add(nums[i]);
            //对下一层进行收集
            backtracking(nums,i + 1);
            //回溯
            path.remove(path.size() - 1);
        }
        return;
    }
}
```

- 甚至可以发现结束条件都可以省去，因为一旦`startIndex`走到了最后再进入for循环时是进不去的，意味着这次递归没有进行，所以结束条件可以省略。

# 90子集II

## 题目要求：

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

<img src="./../../Pic/image-20231229163910040.png" alt="image-20231229163910040" style="zoom:50%;" />

## 第一想法：

上次遇到重复元素的问题，是先进行排序了，上一道题避免重复的发生在于startIndex的功劳，这道题好像光使用startIndex挡不住重复的发生啊，所以在回溯过来for循环进行递增时即递归之前我们要进行多一层的判断，哦我想起来了当时那道重复的题目还设置了一个是否已经使用过的`used`数组。

- 所以used数组初始化为0即为false，每次进入for循环即同一层上的我们进行条件判断，**首先你得满足与上一个值相同，其次还得满足同一层上的上一个相同的值为false。**——因为回溯的缘故，上一个从1变道了0，即false了。
- 一旦满足上面的两个条件就意味着重复了，continue继续本层后面元素的操作。
- 那么其他的操作与上一道子集相同吗？我觉得相同，本质都是子集问题。

## 题解：

## <img src="./../../Pic/IMG_2983(20231229-175541).PNG" alt="IMG_2983(20231229-175541)" style="zoom: 33%;" />

- 还真的让我用以前做过的重复元素的题目used方法给过了，注意其中的回溯和处理结点都要处理used数组（是一个boolean数组）

```java
class Solution {
    private List<Integer> path = new ArrayList<>();
    private List<List<Integer>> result = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        boolean[] used = new boolean[nums.length];
        Arrays.sort(nums);
        backtracking(nums,0,used);
        return result;
    }
    private void backtracking(int[] nums,int startIndex,boolean[] used){
        result.add(new ArrayList<>(path));
        if (startIndex >= nums.length) return;
        for (int i = startIndex; i < nums.length; i++) {
            if (i > 0 && nums[i-1] == nums[i] && used[i-1] == false){
                continue;
            }
            path.add(nums[i]);
            used[i] = true;
            backtracking(nums,i + 1,used);
            used[i] = false;
            path.remove(path.size() - 1);
        }
    }
}
```

