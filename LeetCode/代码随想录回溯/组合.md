# 77组合

## 题目要求：

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例 1：**

```rust
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

## 第一想法：

很典型的回溯问题，以前从来没有接触过；逻辑上定住一个左边，剩下的数根据k来往后找，找到一个合适的加入到结果集中，然后对这个进行回溯，回到左边，再往之前找的之后去找？

根本没有思路啊。

## 题解：

组合是无序的，不能颠倒否则重复；其中元素只能取一次，不能【2,2】这样

### 回溯法三部曲：

1. 递归函数的参数及返回值：
	- 回溯返回值一般为void，**参数n决定数据范围，k来决定路径长度**、以及最重要的startindex，每一次递归都将**本次递归的起始位置**传入。
2. 回溯函数终止条件
	- 当当前路径path中存储的路径满足条件时返回。
3. 单层搜索的过程
	- 处理遍历到的每一个结点，将其加入当前路径中。加入完后进行递归处理，递归完之后回溯删除上一个刚刚操作过的结点。
```java
//定义两个集合一个收集最终结果，一个收集当前路径
private List<List<Integer>> result = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
//回溯
private void backtracing(int n,int k,int startindex){
  if(path.size() == k){
    result.add(new ArrayList<>(path));
    return;
  }
  for(int i = startindex;i <=n; i ++){
    path.add(i);//处理结点，将当前结点先放入当前路径中
    backtracking(n,k,i + 1);//递归处理，对其他结点进行处理
    path.remove(path.size() - 1);//回溯处理
  }
}
//主方法
public List<List<Integer>> combine(int n,int k){
  backtracking(n,k,1);
  return result;
}
```

过程示例：

<img src="../../Pic/image-20231224090519235.png" alt="image-20231224090519235" style="zoom:50%;" />

- 我的理解是每一层for循环代表着一组以x开头的组合
- 在找这个组合的时候会进行递归，但每一次寻找结束就会回溯回来，再次进行下一个for循环（即i++）
- 对于`startindex`,debug时发现其在**最外层的for循环里一直是1**，但是在进行递归时会发生变化，所以他是何种传参类型——基本数据类型每次传参都会创建副本，不会影响原始值，所以`startindex`原始值一直都是1 ！！！

### 剪枝操作：

- 由于在for循环中的**范围过大**，导致有一些没有必要的搜索操作产生，（数已经不够了，你还要去找那不是白瞎吗）；所以我们要在for循环的范围上做文章
- 我们要找到一个位置，**至多从这个位置上开始**，`k-path.size()`即还需要多少元素，所以**`n-(k-path.size) + 1`**即源范围里还剩多少个元素（或者该从哪个元素出发）即所求位置。

```java
private List<List<Integer>> result = new ArrayList<>();
private List<Integer> path = new ArrayList<>();
//回溯
private void backtracing(int n,int k,int startindex){
  if(path.size() == k){
    result.add(new ArrayList<>(path));
    return;
  }
  for(int i = startindex;i <=（n- (k-path.size()) + 1); i ++){//进行剪枝
    path.add(i);//处理结点，将当前结点先放入当前路径中
    backtracking(n,k,i + 1);//递归处理，对其他结点进行处理
    path.remove(path.size() - 1);//回溯处理
  }
}
//主方法
public List<List<Integer>> combine(int n,int k){
  backtracking(n,k,1);
  return result;
}
```



# 回溯的模板

递归-for循环-递归——最终可以视作一个树形结构。

```java
void backtracking(参数){
  if(终止条件){
    存放结果；
    return;
  }
  for(选择：本层集合中元素（树中结点孩子的数量就是集合的大小）){
    处理结点;
    backtracking(路径，选择列表);
    回溯，撤销本次处理结果;
  }
}
```

