# 20 有效的括号

## 题目要求

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。

2. 左括号必须以正确的顺序闭合。

3. 每个右括号都有一个对应的相同类型的左括号。
 ```
   输入：s = "(]"
   输出：false
 ```

## 第一想法

使用栈，将字符串s输入到栈中；首先第一个出栈的不可能是一个左括号，在排除这个可能后（这里我不清楚它能不能实现括号的嵌套啊）如果不能嵌套，则对出栈的右括号的下一个进行判断，是不是相同类型的左括号。依次类推往下出栈。

## 困难

怎么进行同类型判断，s.top() ='{' ?,以及如何拿到栈顶元素的下一个元素呢？

## 正解(巧妙解法)

- 本题是可以实现嵌套的，从内层开始剖析只要都能匹配上就行。
- 对于类型判断，本题可以采用一个绝妙的方法：**在遇到左括号时，进行入栈，入栈的元素并不是左括号本身，而是左括号所对应的右括号。**这样的好处是，在遇到右括号的时候我们需要进行类型判断，直接看二者是否相同就行了，无需其他额外步骤。
- 本题的另一个关键点在于对于可能情况的判断。一共三张可能情况
1. 左括号多了——遍历完字符串后，发现栈里面元素还不为空。
2. 右括号多了——遍历到多余的右括号时，栈里面存放的左括号已经没有了。
3. 中间剖析时发生了类型不匹配——在遍历到右括号时与栈顶进行匹配发生了失配

注意：先判断时可以先看字符串的长度是否为偶数。

总结：遇到左括号就往栈里面放对应的右括号，遇到右括号就去栈顶匹配。
## 代码实现
注意自己写的垃圾代码，对于三种情况的判断没有清楚。
```java
class Solution20{
    public boolean isValid(String s){
        //新建一个栈，栈里面的数据类型为包装类Character
        Stack<Character> stack = new Stack<>();
        if (s.length() % 2 != 0){
            return false;
        }
//        //将所有元素先入栈
//        for (int i = 0; i < s.length(); i++) {
//            stack.push(s.charAt(i));
//        }
//        //进行出栈并判断
//        if (stack.peek() == '(' || stack.peek() =='{' || stack.peek() =='['){
//            return false;
//        }
//        while (! stack.isEmpty()){//这里不会搞了，我怎么同时抓住栈顶和栈顶的下一个元素呢
//            if(stack.)
//        }
        //对字符串进行遍历
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (ch == '(') {
                stack.push(')');
            }else if (ch == '{'){
                stack.push('}');
            }else if (ch == '['){
                stack.push(']');
                //接下来就是遇到右括号了
            }else if (stack.isEmpty() || stack.peek() != ch){
                return false;
            }else {
                //else这里已经是最好的情况，即碰到右括号但是满足23两个条件，出栈
                stack.pop();
            }
        }
        //第一种情况在这里，如果遍历完之后，栈里面还有元素，意味着左括号多了
        return stack.isEmpty();//同时注意这里直接return这条语句，别再写if了，不然大的return难以写出
    }
}
```
## 二刷新想法
### 思路
- 使用栈，遇到左括号将其入栈，遇到右括号去比较当前栈顶元素
- 如果匹配，将栈顶元素出栈，如果不匹配则不符合
- 将三个左右括号分别存在一个builder中，遍历字符串进行操作

### 困难
- 原本想使用类似于contains方法判断所遍历到的字符是否在容器中，结果`StringBuilder`中没有这种方法
- 所以最终还是想复杂了，可以直接利用栈来完成就好，甚至可以有更暴力的方法直接判断

###代码二
```java
class Solution {
    public boolean isValid(String s) {
        /**
         * 暴力判断是否满足条件
         */
        Stack<Character> workStack = new Stack<>();
        for (char c : s.toCharArray()){
            if (c =='(' || c =='{' || c=='['){
                workStack.push(c);
            }else {
                if (workStack.isEmpty()) return false;
                char top = workStack.pop();
                if ((c ==')' && top != '(') || (c == '}' && top != '{') || (c == ']' && top !='[')){
                    return false;
                }

            }
        }
        //最后弄完操作栈应该为空
        return workStack.isEmpty();
    }
}
```
# 1047 删除字符串中所有相邻重复项

## 题目要求

给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

```
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

## 第一想法

栈在操作时的特性：在下一次操作前可以与上一次操作的元素进行互动，对于本题一边入栈一边比较栈顶元素是否与自己相同，如果相同的话就弹出栈顶元素并且不入栈。如果不相同的，可以入栈。直到将整个字符串遍历完，剩余的栈内元素即为想要的。

但是注意如果按照这个思路，剩余的栈中元素应该是ca，输出的话反而是ac，与要求不符合。需要进行颠倒，那么如何颠倒呢？新建一个字符串用于存放？然后记录此时长度，进行固定位置的循环填充？

## 困难

如何颠倒，并且条件梳理少了栈为空的情况。

## 正解

栈为空或者栈顶位置与当前元素不相同，可以进行入栈。不满足这两个条件就得出栈。（因为一旦栈内有元素就得去比较栈顶了）

## 代码实现

```java
class Solution1020{
    public String removeDuplicated(String s){
        Stack<Character> stack = new Stack<>();
        char ch;
        for (int i = 0; i < s.length(); i++) {
            ch = s.charAt(i);
            if(stack.isEmpty() || stack.peek() != ch ){
                //满足这两个条件时，可以进行入栈
                stack.push(ch);
            }else {
                //不为空且栈顶相等了
                stack.pop();
            }
        }
        //剩下的元素要进行出栈并翻转。最后还要成为一个字符串
        int size = stack.size();
        //答案这种方法什么意思，我脑残了，人家是拿每次出栈的元素加上已经有的元素，自然翻转了
        String str = "";
        while (! stack.isEmpty()){
            str = stack.pop() + str;//a——c + a:ca
        }
        return str;
    }
}
```

# 150 逆波兰表达式求值（后缀求值）

## 题目要求：

给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/逆波兰式/128437) 表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

- 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。

- 每个操作数（运算对象）都可以是一个整数或者另一个表达式。

- 两个整数之间的除法总是 **向零截断** 。

- 表达式中不含除零运算。

- 输入是一个根据逆波兰表示法表示的算术表达式。

- 答案及所有中间计算结果可以用 **32 位** 整数表示。

```
  输入：tokens = ["2","1","+","3","*"]
  输出：9
  解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

## 第一想法：

这不就是后缀表达式求值嘛，理论我是会的，至于代码：数字是可以入栈的，运算符没资格入栈，当运算符来到栈顶时，去看栈里面有没有两个数字（如果少于两个数字是什么情况？），有两个数字，就把他们出栈进行计算，注意运算顺序是后者在前进行运算。

运算的结果再次放入到栈中，这样依次进行直到栈里面只剩下一个元素？还是没有运算符了？

## 困难：

对于上面自己想的那些情况可能出现吗？

## 正解：

其实对于后缀表达式，不可能出现只有一个数字并且运算符还入栈的情况，2 + 1 这种就是中缀表达式了。

对于操作顺序问题，需要自己做出一些操作。

## 代码实现：

```java
class Solution150{
    public int evalRPN(String[] tokens){
        Stack<Integer> stack = new Stack<>();//这里栈里面放整型注意
        //注意这次传进来的是一个数组，要遍历数组直接上增强for
        for (String s : tokens){//虽然栈里面放的是整型，但是tokens仍然是字符串数组
            if ("+".equals(s)){
                stack.push(stack.pop() + stack.pop());
                //两个字符串进行计算，放入了Integer栈，这里应该自动装箱了吧
            }else if ("-".equals(s)){
                stack.push(- stack.pop() + stack.pop());
            }else if("*".equals(s)){
                stack.push(stack.pop() * stack.pop());
            }else if ("/".equals(s)){
                int tep1 = stack.pop();
                int tep2 = stack.pop();
                stack.push(tep2 / tep1);
            }else {
                stack.push(Integer.valueOf(s));//这里的类型转换为什么啊？因为上面声明的栈接口类型为Integer,且这里注意对于一个字符串类型如何获得其Integer类型的值
            }
        }
        return stack.pop();
    }
}
```