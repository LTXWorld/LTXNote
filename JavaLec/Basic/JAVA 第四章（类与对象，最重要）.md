# JAVA 第四章（类与对象）

## 类

##三条主线：
1. 类及类的内部成员：属性、方法、构造器；代码块、内部类
2. 面向对象：封装、继承、多态
3. 关键字的使用：final、interface、abstract

### IS（声明）

类修饰符 **class 类名称** extends父类名称 implements接口名称列表；粗体部分必须有，其他可选择。

#### 类修饰符

##### public：

在任何类中使用，**improt语句装载**；没有时，只能在**同一个程序包中使用**，因为不同包中的类是相互不可见的，不能相互引用。

##### abstract：

- 此类**不能被实例化**，由子类来实现这些不具体的功能。最上层的那个类，车、鸟等具有共同特征集大成者。修改时只需要改抽象类就行，不需要每个实例都改。**突出一个重写！！！父债子还**，不能与static，final，private一起。


- 必须产生子类，由子类来创建对象；里面**可以没有抽象方法，有实现的方法都行**；一旦有了抽象方法，必须声明为抽象类。
- **没有方法体**（即{}），在设计模式框架使用较多

##### final：

**不能被继承**，没有子类——包装类Integer，String都是final的，不能被继承。

#### 父类说明

注：**除Object之外，其他类都有父类**，如果没有声明父类，则默认是Object的直接子类。所以所有类都是其子类

`class 类名 extends 父类名`

extends**只能实现单继承**（接口可extends多继承）

#### 接口

类声明的最后使用implements **接口名可以用逗号分开，有多个接口**；定义类之间行为的协议。

### 类何时加载（必背）：

1. 创建实例对象时（new）
2. 创建子类对象时，父类会被加载——**先加载父类，再加载子类**。
3. 使用类的静态成员时，也会加载。
4. 类只在方法区加载一次，创建不同对象时堆栈中开创两个实例化空间

### HAS

#### 成员变量声明

声明必须在类体中，而不是在方法体中；成员变量和方法可以重名

**[可访问性修饰符] [static] [final] 类型 变量名**；[]是可选项

#### 域（访问）修饰符

- public  四个范围可以随意访问
- protected 本类、同包、子类、**不同包不能访问**
- 默认无修饰符：本类、同包、**子类不同包不能访问**
- private ：只在本类
- 不同包下只可以访问public；同包下除了私有以外都能访问

限制强度依次是private -**默认同包**-  protected（子类同包） -  public

注意：

- protected **变量必须被子类继承过来后，作为子类对象的成员使用——即父类的x，你在子类中要new 子类的对象，用子类的对象去调用x**

- 同一个类两个对象可以互相访问其私有变量。(限制的是类层面，不是对象层面)
- **只有默认以及public才可以修饰类**

#### Static静态

##### 概念

- 最大的特点就是被此类所有的对象所**共享**（不同对象访问的是一个）；**最好通过类名访问**（类名.静态变量，因为加载时就有了）。

- 实例变量各对象独享

##### 内存布局

- 在加载的时候生成，**生命周期随着类存在而存在**。

- jdk8之前放在方法区当中；8以后类加载时，在**堆里面生成对应的class对象（创建其他对象时以此为原型）**，故静态变量存放在**堆里面**的class对象中。

#### FINAL

- 定义后就不能修改，固定常量。一般使用大写名称。
- **必须初始化**，但是可以在三个位置赋值——定义时、构造器、代码块（后面两者本质一样）；如果是**静态的，初始化不能在构造器中**，因为静态变量类加载就要给值，构造器创建对象时才触发
- **与static搭配使用，效果更佳。不会导致类的加载**。
- **形参**里面可以加 final ，返回时可以进行+-操作
```java
class E(){
 final int max;
 public E(){
 	max = 2;
 }
 public E(int m){
 	max = m;//这里与常量不冲突，因为你想要改变值得新建一个其他对象
 }
}
```

#### 局部内部类：
- 注意事项：当做一般的局部成员来看待；*与成员内部类区分开*
	1. 放在==方法或代码块中的==，**不能有访问控制修饰符，且不能用static修饰**
	2. 在外部类中不能创建内部类的实例
	3. 创建其实例只能在包含它的方法中
	4. 只能在方法体中访问局部内部类
	5. 局部内部类可以访问定义它的方法中的局部变量，但是这些变量必须是 final 或者事实上的 final（即从定义开始到使用结束都没有改变过）。
	6. 封装：局部内部类是一种很好的封装工具，可以将复杂的辅助类隐藏在一个方法内部

```java
public class OuterClass {

    public void display() {
        class LocalInnerClass {//局部内部类
            public void print() {
                System.out.println("Inside Local Inner Class");
            }
        }
        
        LocalInnerClass localInnerClass = new LocalInnerClass();
        localInnerClass.print();
    }
    
    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        outer.display();
    }
}

```
### DOSE

#### 成员方法

基本数据类型传参——传递的是值，形参改变不影响实参。

引用类型传参——传的是地址，形参和实参会相互影响。


#### 方法修饰符

##### ABSTRACT 方法

当前抽象类所有子类都使用这个接口来完成同一动作，但具体动作实现内容不同。

*==抽象方法必须在抽象类中，但抽象类中可以不止有抽象方法==；抽象类的子类如果不是抽象类，必须去实现父类的所有抽象——父债子还*

- ` public abstract void eat();`没有方法体，大括号也不要
##### 类方法与实例方法（静动）

- static 方法**只能**处理 static 域——类方法不能操作实例变量；只会有一个版本，所有实例共享。（因为生命周期，实例变量还没生成呢）


- 类的所有对象都共享一个实例方法的相同实现，但是实现环境不同。


- **静态方法可以直接通过类名调用，无须创建对象**。就算是空指针对象去调用也没关系
- **不使用this，super**关键字

###### 使用场景

- 方法中**不涉及任何与对象相关**的成员时，可以将其设计为静态方法。
- 不创建对象，也可以使用某个方法，**当作工具使用**。例如Math.sin()
- main方法详解：public static void main(String[] args){}
  1. main方法**虚拟机调用**，必须public(虚拟机)  static（无需创建对象）
  2. args如何传入：执行程序时命令行传入的参数会形成一个数组传进去。（终端运行时传，idea里面在右上角执行旁边可以打开）
  3. 在main方法中，可以直接调用**main方法所在的类的静态东西**，但是不能直接访问非静态的，要创建对象。

##### FINAL 方法

- **不能被当前类的子类重新定义的方法**。即不能进行方法的重写override——从父类中革新（注释掉super），但是父类的构造方法子类不能用，得自己写constructor。但是子类还可以用，只是不能重写。

- 保证安全可靠
- **与static搭配使用，效果更佳。不会导致类的加载**。

##### 本地方法native

引入其他语言写好的特殊方法，但必须保证跨平台性。

##### 同步方法synchronized

使用方法时，将当前对象加锁——多线程共存。

#### 方法的返回类型

注意可以返回一个类，但是返回的结果一定要保存——比如在方法中返回时创建了一个新对象，在某对象调用时要创建新对象接一下

返回基本类型时，容易造成返回值没有保存在对象当中，只是简单的输出了。

#### 方法的重载

**同一个类中**重载的方法不一定要返回相同的数据类型，只需要**同一方法名**就可以自动选择不同版本。

多个重载的方法**参数必须有一定区别**——**类型，顺序，个数**。（注意与形参名字无关，与返回类型也无关）

如

#### 方法的参数

注意带this前缀的是成员变量；Java不允许将方法作为参数传递到方法中，但可以传对象。

**当传入参数为引用类型时**，不能改变引用（指针），但是对于**值的改变外部可见**，因为在**方法中的参数与实例中参数都指向同一区域**。

**当传入参数为简单类型时**，方法对参数所做的改变**对外不可见**——即传入String类型，在方法中给他+，但是最终输出还是原来的值（改变只在内部）

#### 可变参数

- 访问修饰符 返回类型 方法名（数据类型**...** 形参名）三个点很重要

- **多个同名功能也相同但参数个数不同**，使用可变参数优化（当作**数组**）

```java
public int sum(int... nums){
	//可以接受多个参数0个或者多个
	//使用时可以当作数组使用。
    //来一个具体实现
    int res =0;
    for(int i=0;i < nums.length;i++){
        res +=nums[i];
    }
    return res;
}
```

- 实参可以直接是数组
- 可变参数可以与普通参数一起放在形参列表，但可变参数必须放在最后。
- 只能有一个可变参数。

#### 方法体

- this 代表了当前对象的一个引用，仅仅作为对象的名字使用。


- super 代表当前对象的**直接父类对象引用**。


- 变量的作用域决定了什么时候创建内存，什么时候清除内存。——成员变量、方法参数、局部变量（必须初始化）、异常处理参数


### 代码块（初始化块）：

#### 概念

- 相当于另外一种形式的构造器，可以初始化（因为有的需要方法调用初始化，要传参，得写在代码块里面）
- *多个构造器中有重复的语句，抽取到代码块中*，提高复用性
- **都会先调用代码块，再调用构造器。**
- 内部可以声明变量、调用属性和方法、写一些输出语句等
```java
    private double price;
    private String name;
    private String actor;
    //这个代码块，不论哪个构造器创建对象，都会先调用代码块。
    {
        System.out.println("---");
    }
    public Movie(double price) {

        this.price = price;
    }

    public Movie(double price, String name) {
        this.price = price;
        this.name = name;
    }
```
#### 基本语法

[修饰符]{

代码};

- 修饰符可选，==要写也只能是static==


#### 使用细节

- 如果代码块用**static**修饰，**随着类的加载（见上）而执行，只执行一次**。
- **普通代码块**，创建**对象**时被调用；每创建一次调用一次。（与类加载无关）——通常只写一个代码块，就算多个也会（后期）自动合并为一个
- 创建一个对象时，在**一个类调用顺序**是
  1. 调用静态代码块和静态属性初始化（二者优先级相同）
  2. 调用普通代码块和普通属性（优先级相同）
  3. 最后调用构造器

- 有**继承关系**时：构造器最前面其实隐含了**super()**和调用**本类的普通代码块和普通属性**

```java
class A{
	public A(){
		//隐藏了语句
		//super();
		//调用普通代码块和普通属性的初始化
		System.out.println("OK");
	}
}
```
- 创建一个子类对象时，调用顺序如下(先进行**类的加载**12，再**创建对象**3456)
  1. 类的加载——父类的静态代码块和静态属性
  2. 子类的静态
  3. super——父类的普通
  4. 父类的构造器
  5. 出super回到子类——子类的普通
  6. 子类的构造器

####实例变量赋值顺序
- 默认初始化-显示赋值/代码块赋值-构造器赋值-对象赋值
- 实例变量值一样时，显示赋值；各不相同时构造器赋值

<img src="../../LTXWorld.github.io/assets/blog_res/image-20231006143645438.png" alt="image-20231006143645438" style="zoom: 33%;" />

- ==注意没写this、super时默认是this==，所以上面的method方法会去下面那个重写的方法执行

### 对象的创建与撤销

#### 构造

- 使用构造方法constructor新建对象——构造方法会有一个参数表（）

- 支持构造方法的**重载**；**构造方法方法名与类名相同**，无返回类型，不能被一些修饰符修饰，**要使用new关键字调用**，不能用.调用

- 类名 对象名  = new 构造方法名（参数表）；平常那个是使用了**默认的构造方法**

- 一般不用构造方法，除非要进行一些特殊的初始化。

#### 撤销

Java中垃圾收集器，周期性地清楚不再被引用的对象。System的gc()方法可以调用运行。

### 嵌套类

作为一个类的成员，嵌套类在此类中可以无限制的访问所有成员。此类地位相当于一个成员变量。

嵌套类也可以单独产生字节码文件，文件名格式：*外部类名+$+嵌套类名.class*

### 程序包（相当于目录）

为了方便管理，通常将相关或者一起协同工作的类和接口放在一个包中。

lang包——基本语言类；io包——输入输出；util包——实用的数据类型；awt包——GUI

**建包package语句是整个java文件的第一个语句——package 包名**；

使用：1装载整个包：import 包名；2 装载某个包的某个接口 import 包名.接口名；注意使用包名来包裹类名排除二义性。

## 枚举类(enum)

事先规定好状态。继承自Enum类（泛型）;枚举出来的这三个相当于final常量

```JAVA
public enum Status{//定义一个枚举类状态
	RUNNING,STUDY,SLEEP;
}
```
在学生类中使用枚举类，作为成员变量的数据类型并封装。
```java
package com.Test_enum;

public class Student {
    private Status status;

    public Status getStatus() {
        return status;
    }

    public void setStatus(Status status) {
        this.status = status;
    }
}

```

枚举类自带的方法:valueOf

特殊写法：原本默认无参构造方法，现在自己写一个**有参构造方法的话，上面定义的三个就要加（）**

```java
public enum Status {
    Running("跑步"),Studying("学习"),Sleeping("睡觉");
    private String name;
    Status(String name){
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
```

## 对象创建流程

```java
Person p = new Person("lll",20);
```

- 栈
- 堆
- 方法区在堆里面
- 常量池在堆里面

1. 先在**方法区加载person类**信息。

2. new对象**在堆里面开辟空间**并进行初始化——先默认初始化，再显示的初始化

3. 最后执行构造器初始化属性。

4. 完成后将**堆内对象地址给到p这个对象引用（在栈里面）**

   