# Java第五章 封装、继承与多态

## 封装

### 概念

- 类里面有很多数据，复杂方法，但是**具体方法怎么实现的被封装起来**，你只需要传参数即可。

- 在封装内部控制数据的合理性。

- 体现程序设计的原则：==高内聚，低耦合==（对内以类的形态呈现，方法封装在类内；对外暴露少数的方法）

### 步骤

1. 属性私有化private
2. 提供一个公共的set方法（即在set方法中修改属性并加入验证方法）
3. 提供一个公共的get方法（可以来判断权限）

### 细节

可以**与构造器连用**，即*将构造器中的this改成对应的get set方法*。

### 权限修饰符（最能体现封装性）

- 修饰类的内部成员

- 对于类只能用public和缺省
- 对于类的成员可以使用四种
- <img src="../../LTXWorld.github.io/assets/blog_res/image-20230930161914659.png" alt="image-20230930161914659" style="zoom:50%;" />
	1. 当前类中权限再小都能调
	2. 出了包之后不能调用缺省
	

### 构造器
- ==用来构造（创建）对象  ； 为对象属性初始化赋值==
- 一旦声明了非空的构造器，默认给的空参构造器就不提供了

### 匿名对象
- 某个new出的对象==只能被调用一次==，通常作为实参传给方法的形参

###补充：对于实例变量
- 每个对象都有一份的（与后面的static对应）
- 赋值方法：<img src="../../LTXWorld.github.io/assets/blog_res/image-20230930172624273.png" alt="image-20230930172624273" style="zoom:50%;" />

###JAVABean
- 要求：<img src="../../LTXWorld.github.io/assets/blog_res/image-20230930173746022.png" alt="image-20230930173746022" style="zoom:50%;" />
- 好处：方便写出统一性的代码

## 继承
### this 关键字
- this调用的是成员变量，可以调用成员变量、方法、构造器
- 可以由当前对象（方法中使用）or当前正在创建的对象（构造器使用）
- 构造器的形参与==正在创建对象的属性==相同了

** This可以调用构造器**
 - <img src="../../LTXWorld.github.io/assets/blog_res/image-20231001114022013.png" alt="image-20231001114022013" style="zoom:50%;" />
 - 在类的构造器中，使用`this（形参列表）`可以调用其他的指定的构造器，==必须声明在当前构造器体的首行==
### 概念

解决代码**复用性**，父类构造器完成父类属性初始化，子类构造器完成子类属性初始化，通过super实现

- 一个类从另一个类中**自动获得**状态和行为（父类）；允许一个类建立在其他类之上——自行车类对于山地自行车、赛车自行车类


- 子类除了继承来的东西之外，**可以自己增加变量方法，甚至可以自行改变继承来的方法**


- **逐级继承**，约在分级结构的下方，更多的状态行为；**但不能同时继承多个类**，即extends A,B
- class 子类 extends 父类

一般采用==**单继承的树状结构**，==而*多继承通过接口来实现*。所以单继承就会有严格的类的层次结构。

### 继承的细节

#### 普通细节

- 子类可以从父类那里继承**所有域和方法，但是私有的不能直接用**，要通过**父类提供公共的方法**去访问（即给私有的套个盒子再用）。
- 创建子类对象，不管用哪个子类构造器，**都会默认调用父类的无参构造器**；父类如果没有无参构造器，则必须在**子类的每一个构造器中去指定使用super调用**父类的有参构造器——super(参数列表)
- super在使用的时候必须放在构造器的**第一行**，**且只能在构造器中使用**——还有this（本类的构造器），**二者不能同时存在**。
- 父类构造器的调用*不限于直接父类*，一直往上追溯到Object
- 不能滥用继承

#### 域的继承与隐藏

- 子类除了可以继承所有父类的非私有域之外，还可以重新定义一个与父类域名相同的变量——域的隐藏。**（对同名父类变量的隐藏）**

- 使用父类方法时用的是父类域，用自己方法用自己变量。

#### 方法的继承与覆盖

- 覆盖是指子类可以重新定义父类的方法，实现自身的行为，但**必须要相同的方法头部声明**（名称、参数相同）。——alt+insert + override


- 保证相同的方法名，参数列表，**返回类型：父类为基本数据类型，子类必须与其相同；父类为引用类型，子类小于等于其即可**。注意与域的隐藏区别，域的隐藏父类域还是存在的，方法覆盖父类域就没有了。
- 子类覆盖不能缩小父类的方法范围——public、protected、默认、private
- 注意，==不能重写父类的private方法==
- 与重载的区别：重载是一个类中的相似方法，重写是继承子父类的问题

### 内存本质（重要）

子类继承父类后，内存中发生了什么？
```java
package com.luluedu.extend;

public class ExtendsTheory {
    public static void main(String[] args) {
        Son son = new Son();
        //内存怎么布局的？
    }
}
class Grandpa{
    String name = "爷爷";
    String hobby = "旅行";
}
class Father extends Grandpa{
    String name = "大头爸爸";
    int age = 39;
}
class Son extends Father{//子类
    String name = "大头儿子";
}
```

1. 加载son类时，**先查找并加载父类信息**。
2. 堆空间内容：分配**各个父类的独立空间**以保存属性；整个堆的地址分配给主方法中son对象
3. <img src="E:\photo\30F5C6C8765A71CC1608857AA998CC54.png" style="zoom:50%;" />

访问name时，访问的是谁？

1. 首先看**子类**是否有，**如果有且可以访问（私有，但即使私有也可以再套个方法去访问）**，则返回信息。
2. 如果子类没有此属性，向上寻找父类有无此属性，直到Object。
3. 注意，**私有不代表没有**，找到私有的但方式错误会报错，不会再向上找。

### surper关键字

#### 概念

- 子类对父类的方法重写后，是否还能对父类的方法进行调用

- 代表父类的引用，==访问父类的属性、方法、构造器。==

#### 语法

1. 访问父类的**非私有**属性及方法。
2. 访问父类的构造器只能出现在**子类某构造器的第一句**。
3. 当子类有和父类中属性方法重名时，**为了访问父类成员，必须使用super**。如果不重名，可直接调用。（因为找某方法顺序是从本类一直找到Object，但是如果使用super直接会去父类查找。）
4. 所以子类的任何构造器中，要么调用的是本类重载的构造器（this），要么调用的是父类的构造器（super）——正是因为调用父类的构造器，才会加载（具有）父类的属性和方法

## 多态

- **对象和方法**具有多种形态。主要指的是==子类对象的多态性（编译和运行的不一致动态性）==
- 不适用于属性！！！
- 经常使用场合：*使用父类作为方法的形参，即使添加了新的子类，方法也不需要改变。符合开闭原则。*；多态无处不在，后面的接口和抽象类的前提。

### 方法体现多态

- **同名的不同方法在程序中共存。**——一个名字，多个方法，遇情况看选择具体的哪一个。

- 实现方法：方法的覆盖；重载（根据参数的不同来区分即可）。**调用方法时看运行类型，再根据查找关系从子到父。**

#### 覆盖实现

由于方法声明一样，调用时需要**指明这是哪个类或者对象的方法**。类名.方法；对象.方法。

#### 重载实现

参数必须有区别。

### 对象体现多态（核心）

#### 记住这几句

1. 一个对象的**编译类型和运行类型**可以不一致。Animal animal = new Dog（）；animal编译类型是Animal，运行类型是Dog；Animal animal = new Animal（）,这就是一致的情况。
2. **编译类型不变**在定义对象时，就已经确定了。
3. **运行类型可以改变**。animal = new Cat();运行类型从Dog变成了Cat
4. 前提是：要有类的继承+方法的重写
5. ==编译类型要看定义时等号的左边，运行类型看右边==——堆里面真正的对象。但**只有运行时才能确定具体是哪个子类。**
6. 执行的结果依赖于当前对象的运行类型，**表面是编译类型（编译器看到的类型），实际运行是运行类型**。披着羊皮的狼。（==虚方法调用==）
7. 极大减少代码的冗余，避免去写很多重载的方法。但是有*缺点*：==屏蔽了子类的属性和方法，除非转型==——针对创建的对象，不能调用子类中声明的方法和属性！！！` Person p1 = new Man();` 
8. <img src="../../LTXWorld.github.io/assets/blog_res/image-20231003094836718.png" alt="image-20231003094836718" style="zoom:50%;" />

#### 上下转型
```java
public void feed(Animal animal,Food food){
	//animal编译类型为Animal可以接收（指向）其子类对象。
}
```

1. 前提是，两个对象（类）**存在继承关系**。
2. 向上转型 ——父类的引用指向了子类的对象。 举例：*父类类型 引用名 = new 子类类型（）*;

```java
HuaHu huahu = new Huamulan();//向上转型,虽然是花木兰的构造方法，但是用的是他爸的类名
Huamulan huamulan = (Huamulan)huahu;//强制类型转换，转换回花木兰。向下转型。
```

3. *向上转型*调用规则：**可以调用父类的所有成员（遵循访问权限private），不能调用子类的特有成员。最终运行结果看子类的具体实现，调用方法时从子类开始查找方法**。原因：编译阶段：*调用时是看编译类型；而一旦写完代码运行起来就要看运行类型*。
3. 向下转型**为了调用子类的特有成员**：*子类类型 引用名 = （子类类型）父类引用*；**只能强转父类的引用，不能强转父类的对象**；向下转型后就可以调用子类的特殊成员。(就是*强制类型转换成子类，原本由于左边的编译类型导致不能访问子类，现在要访问就得改变编译类型*)
3. **要求父类引用必须指向的是当前目标类型的对象**——即animal原先就得指向cat
```java
Animal animal = new Cat();//向上转型
Cat cat = (Cat) animal;//向下转型
Dog dog = (Dog) animal;//不符合第五个要求。
```

### 细节

- 属性没有重写
- instanceOf 可以判断对象的**运行类型**是否为某类型或其子类型。——向下转型会出现类型错误（但编译器不会报错），故转型之前使用instanceof
- **属性看编译类型，方法看运行类型**（等于内存地址）。

### 动态绑定机制（重要）

1. 当调用对象方法时，该**方法**会和该对象的内存地址**（运行类型）绑定**。
2. 调用对象**属性时，没有动态绑定**，**哪里声明，哪里使用**。

## 多态应用

### 多态数组

熟练掌握上下转型，调用时往往看编译类型即你要.什么东西时；而写完代码运行时结果往往得看运行类型，即在jvm中真正运行起来。

### 多态参数

方法定义的形参为父类类型，实参类型允许为子类类型（见上面转型代码1）

## 构造方法的继承与重载

### 重载

同一个类中定义不同参数的多个构造方法，**完成不同情况下的初始化**。

一个类中**不同构造方法可以相互调用**，使用this指明。

### 继承

满足三个原则：

1 若有子类，父类一定要有无参构造方法给到子类来继承。

2 如果子类没定义构造方法，将继承父类无参方法；如果子类定义了构造方法，在创建新对象时，先执行来自父类的无参构造方法，再执行自己的。

3 对于父类的带参构造方法，子类可以在自己的构造方法中用super关键字调用父类的。**此调用语句必须是子类构造方法第一个可执行语句。**super(参数1，参数2)；

## 接口（interface）

### 概念（拓展继承）

- 类是事物的抽象，接口是事物**行为的抽象**，因为抽象所以它不能被实例化。——==接口是一种规范==！！！

- *一个类只能直接继承一个父类，而接口的出现可以同时实现若干接口*，即实现了**多重继承**。

- 定义了若干**抽象方法与常量**，形成一个属性集合，即某一特定功能。功能的真正实现在继承接口的类中具体完成。

- 对接口功能的继承下来后具体的实施过程称为**实现（implement）**——alt+enter快速实现

### 特点

- 接口不能有**任何实现了的方法**（抽象类可以有）即可以有**静态的static、默认的default 实现的方法**；接口不能有任何变量，**全是常量**（抽象类可以）；接口不是类层次的一部分。

- 可以声明接口的变量，必须引用实现了接口的类对象；
- 接口中的方法**自动设置为了public abstract，域（变量）自动设置为public static final**；在具体实现时要加上public；*抽象类实现接口时可以不实现接口的抽象方法。*如果此类想实例化，必须实现接口的抽象方法
- 由于每个类只能扩展一个类，而接口可以实现多个。所以这就是为什么使用接口。
- 当某个类继承了一个超类又实现了一个接口时，而这有相同的方法——**只会考虑超类的方法**==类优先原则==
- 接口不能*继承*其他类，==可以继承多个别的接口==。
- 接口的**修饰符只能是public和默认**
### 新特性
- 接口中声明的static方法只能由接口来调用，不能使用其实现类调用
- 默认方法可以实现类继承、重写；但可能会发生接口冲突（两个接口定义了同名同参数的默认方法）
```java
CompareA.super.method2();//调用接口A中的默认方法
```
### 定义

`[public] interface 接口名 [extends 父接口表]{域类型 域名 = 常量值；返回值 方法名（参数表）；}`

父接口可以有很多，用逗号分隔。注意：**接口类型也可以作为方法的参数。**

### 实现

- 必须使用一个类来实现接口。implements+接口名；记得同时实现接口中的方法。


- 注意：**类在实现抽象方法时，必须使用public修饰符**；非抽象类中不能有抽象方法存在；**接口不能被覆盖（多个版本）可以去继承**。
- 通过接口去调用方法
- 继承与接口实现可以一起进行

### 与继承对比

- 设计好规范，比继承更加灵活——继承满足cat is a Animal的关系；接口只要满足 like像的关系。
- 实现**代码解耦**（接口规范性+动态绑定）

### 接口多态特性

- 接口类型可以指向实现了接口的对象（向上转型）
- 因为接口不能造对象，所以形参为接口，主方法中肯定是new的实例对象。展现了多态。

### 匿名内部类

- 原本要写一个类来具体实现接口的，但是在主类中可以直接新建接口类型，在主类中就可以具体实现。
- 内部类B只在类A中使用，所以不用写在别的地方了。
```java
public static void main(String[] args){
//创建接口匿名实现类的对象：本来是不能new 接口的，但这里要匿名所以必须得new，new了之后就得之后去临时实现接口中的抽象方法
		USB usb = new USB(){
			public void start(){
				sout
			}
			public void stop(){
				sout
			}
		}
		computer.trans(usb);
		//或者还可以更简单，创建接口匿名实现类的匿名对象
		computer.trans(new USB(){
			public void start(){
				sout
			}
			public void stop(){
				sout
		});
}

interface USB{
	void start();
	void stop();
}
```
### 克隆

创建一个新对象，初始状态与原始相同，之后各自有不同的状态。默认为浅克隆（不克隆可变的子对象）

## Object类详解
### 概念：
- 没有属性，重点关注方法
- equal、toString、clone、finalize

### equals与==区别

- ==：既可以判断基本类型，又可以引用类型——值相等、地址相等（对象是否相等）
- equals是Object类方法，**只能传引用类型**。没有重写的**Object的equals==默认判断对象地址是否相等==**；而比如**String类型的经过了重写，判断内容。**
- File、Date、包装类都将equals重写了；对于自定义的类，常常会去重写equals方法
```java
public boolean equals(Object obj){
	if(this == obj){
		return true;
	}
	if(obj instanceof Order){
		Order order = (Order) obj;//注意这里为什么要向下转型（因为进来的时候形参那里就已经是顶级父类Object了，需要调用子类的方法如equals）
		return this.orderId == order.orderId && this.orderName.equals(order.orderName);
	}
}
```
- 可以自动实现ctrl+N；==但是需要注意==：如果比较属性时，里面具有引用类型的属性，我们需要对这个引用类型（类）再次重写——因为会去调用里面这个引用类型的equals方法

### clone
- 创造对象的一个复制品，重新造了一个对象而不是原来那个地址。
- 创建对象的又一种方法

###finalize
- 在使用GC回收时可以调用，（临死前还有什么东西吗）
- 在JDK17中已经不太推荐使用，会有死锁的风险
### hashcode（先记结论）

1. 提高哈希结构的容器效率
2. **两个引用指向同一对象**哈希值相同；不同对象哈希值大概率不一样
3. **哈希值主要根据地址计算，但不等价于地址**。因为对象的真正地址无法拿到，不得已转换为一个整数实现。
4. 在集合中，hashcode往往会被重写。

### toString

默认返回：**全类名（包名+类名）+@+哈希值（整数地址）十六进制**
```java
public String toString() {
   return getClass().getName() + "@" + Integer.toHexString(hashCode());
 }
```

通常重写，进行打印对象或者拼接对象时。**使用alt+insert 生成，一般将对象的属性输出**。

*当直接输出一个对象时，toString方法会被默认调用*。

